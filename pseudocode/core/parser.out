Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> func_l_op l_op
Rule 2     program -> l_op
Rule 3     l_op -> op
Rule 4     l_op -> op l_op
Rule 5     func_l_op -> func
Rule 6     func_l_op -> func func_l_op
Rule 7     ar_op -> add
Rule 8     ar_op -> mul
Rule 9     ar_op -> sub
Rule 10    ar_op -> div
Rule 11    ar_op -> rdiv
Rule 12    ar_op -> mod
Rule 13    add -> ID PLUS ID
Rule 14    add -> CONST PLUS ID
Rule 15    add -> ID PLUS CONST
Rule 16    add -> CONST PLUS CONST
Rule 17    sub -> ID MINUS ID
Rule 18    sub -> CONST MINUS ID
Rule 19    sub -> ID MINUS CONST
Rule 20    sub -> CONST MINUS CONST
Rule 21    mul -> ID TIMES ID
Rule 22    mul -> CONST TIMES ID
Rule 23    mul -> ID TIMES CONST
Rule 24    mul -> CONST TIMES CONST
Rule 25    div -> ID DIV ID
Rule 26    div -> CONST DIV ID
Rule 27    div -> ID DIV CONST
Rule 28    div -> CONST DIV CONST
Rule 29    rdiv -> ID DIVIDE ID
Rule 30    rdiv -> CONST DIVIDE ID
Rule 31    rdiv -> ID DIVIDE CONST
Rule 32    rdiv -> CONST DIVIDE CONST
Rule 33    mod -> ID MOD ID
Rule 34    mod -> CONST MOD ID
Rule 35    mod -> ID MOD CONST
Rule 36    mod -> CONST MOD CONST
Rule 37    attr -> ID ASSIGN ID
Rule 38    attr -> ID ASSIGN CONST
Rule 39    attr -> ID ASSIGN ar_op
Rule 40    attr -> ID ASSIGN TRUE
Rule 41    attr -> ID ASSIGN FALSE
Rule 42    attr -> ID ASSIGN func_call
Rule 43    ret_op -> RETURN ID
Rule 44    ret_op -> RETURN CONST
Rule 45    ret_op -> RETURN ar_op
Rule 46    ret_op -> RETURN func_call
Rule 47    op -> ar_op
Rule 48    op -> attr
Rule 49    op -> write
Rule 50    op -> read
Rule 51    op -> func_call
Rule 52    op -> repeat
Rule 53    op -> ret_op
Rule 54    op -> if
Rule 55    op -> while
Rule 56    op -> for
Rule 57    cond -> TRUE
Rule 58    cond -> FALSE
Rule 59    cond -> cond_op
Rule 60    cond_op -> ID LOWER ID
Rule 61    cond_op -> ID LOWER CONST
Rule 62    cond_op -> CONST LOWER ID
Rule 63    cond_op -> CONST LOWER CONST
Rule 64    cond_op -> ID GREATER ID
Rule 65    cond_op -> ID GREATER CONST
Rule 66    cond_op -> CONST GREATER ID
Rule 67    cond_op -> CONST GREATER CONST
Rule 68    cond_op -> ID LEQUAL ID
Rule 69    cond_op -> ID LEQUAL CONST
Rule 70    cond_op -> CONST LEQUAL ID
Rule 71    cond_op -> CONST LEQUAL CONST
Rule 72    cond_op -> ID GEQUAL ID
Rule 73    cond_op -> ID GEQUAL CONST
Rule 74    cond_op -> CONST GEQUAL ID
Rule 75    cond_op -> CONST GEQUAL CONST
Rule 76    cond_op -> ID EQUAL ID
Rule 77    cond_op -> ID EQUAL CONST
Rule 78    cond_op -> CONST EQUAL ID
Rule 79    cond_op -> CONST EQUAL CONST
Rule 80    cond_op -> ID NEQUAL ID
Rule 81    cond_op -> ID NEQUAL CONST
Rule 82    cond_op -> CONST NEQUAL ID
Rule 83    cond_op -> CONST NEQUAL CONST
Rule 84    cond_op -> ar_op LOWER ar_op
Rule 85    cond_op -> ar_op GREATER ar_op
Rule 86    cond_op -> ar_op LEQUAL ar_op
Rule 87    cond_op -> ar_op GEQUAL ar_op
Rule 88    cond_op -> ar_op EQUAL ar_op
Rule 89    cond_op -> ar_op NEQUAL ar_op
Rule 90    cond_op -> ar_op LOWER ID
Rule 91    cond_op -> ar_op GREATER ID
Rule 92    cond_op -> ar_op LEQUAL ID
Rule 93    cond_op -> ar_op GEQUAL ID
Rule 94    cond_op -> ar_op EQUAL ID
Rule 95    cond_op -> ar_op NEQUAL ID
Rule 96    cond_op -> ID LOWER ar_op
Rule 97    cond_op -> ID GREATER ar_op
Rule 98    cond_op -> ID LEQUAL ar_op
Rule 99    cond_op -> ID GEQUAL ar_op
Rule 100   cond_op -> ID EQUAL ar_op
Rule 101   cond_op -> ID NEQUAL ar_op
Rule 102   cond_op -> ar_op LOWER CONST
Rule 103   cond_op -> ar_op GREATER CONST
Rule 104   cond_op -> ar_op LEQUAL CONST
Rule 105   cond_op -> ar_op GEQUAL CONST
Rule 106   cond_op -> ar_op EQUAL CONST
Rule 107   cond_op -> ar_op NEQUAL CONST
Rule 108   cond_op -> CONST LOWER ar_op
Rule 109   cond_op -> CONST GREATER ar_op
Rule 110   cond_op -> CONST LEQUAL ar_op
Rule 111   cond_op -> CONST GEQUAL ar_op
Rule 112   cond_op -> CONST EQUAL ar_op
Rule 113   cond_op -> CONST NEQUAL ar_op
Rule 114   if -> IF cond ATUNCI l_op ENDIF
Rule 115   if -> IF cond ATUNCI l_op ELSE l_op ENDIF
Rule 116   while -> WHILE cond EXECUTA l_op ENDWHILE
Rule 117   for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
Rule 118   for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
Rule 119   for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
Rule 120   for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
Rule 121   for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
Rule 122   for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
Rule 123   for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
Rule 124   for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
Rule 125   repeat -> REPEAT l_op UNTIL cond_op
Rule 126   read -> READ LPAREN l_param RPAREN
Rule 127   write -> PRINT LPAREN l_a_param RPAREN
Rule 128   func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION
Rule 129   func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION
Rule 130   func_call -> ID LPAREN l_a_param RPAREN
Rule 131   func_call -> ID LPAREN RPAREN
Rule 132   l_param -> ID
Rule 133   l_param -> ID COMMA l_param
Rule 134   l_a_param -> CONST
Rule 135   l_a_param -> ID
Rule 136   l_a_param -> ar_op
Rule 137   l_a_param -> func_call
Rule 138   l_a_param -> l_a_param COMMA CONST
Rule 139   l_a_param -> l_a_param COMMA ID

Terminals, with rules where they appear

ASSIGN               : 37 38 39 40 41 42 117 118 119 120 121 122 123 124
ATUNCI               : 114 115
COMMA                : 117 118 119 120 121 121 122 122 123 123 124 124 133 138 139
CONST                : 14 15 16 16 18 19 20 20 22 23 24 24 26 27 28 28 30 31 32 32 34 35 36 36 38 44 61 62 63 63 65 66 67 67 69 70 71 71 73 74 75 75 77 78 79 79 81 82 83 83 102 103 104 105 106 107 108 109 110 111 112 113 118 119 120 120 121 122 122 123 123 124 124 124 134 138
DIV                  : 25 26 27 28
DIVIDE               : 29 30 31 32
ELSE                 : 115
ENDFOR               : 117 118 119 120 121 122 123 124
ENDFUNCTION          : 128 129
ENDIF                : 114 115
ENDWHILE             : 116
EQUAL                : 76 77 78 79 88 94 100 106 112
EXECUTA              : 116 117 118 119 120 121 122 123 124
FALSE                : 41 58
FOR                  : 117 118 119 120 121 122 123 124
FUNCTION             : 128 129
GEQUAL               : 72 73 74 75 87 93 99 105 111
GREATER              : 64 65 66 67 85 91 97 103 109
ID                   : 13 13 14 15 17 17 18 19 21 21 22 23 25 25 26 27 29 29 30 31 33 33 34 35 37 37 38 39 40 41 42 43 60 60 61 62 64 64 65 66 68 68 69 70 72 72 73 74 76 76 77 78 80 80 81 82 90 91 92 93 94 95 96 97 98 99 100 101 117 117 117 118 118 119 119 120 121 121 121 122 122 123 123 124 128 129 130 131 132 133 135 139
IF                   : 114 115
LEQUAL               : 68 69 70 71 86 92 98 104 110
LOWER                : 60 61 62 63 84 90 96 102 108
LPAREN               : 126 127 128 129 130 131
MINUS                : 17 18 19 20
MOD                  : 33 34 35 36
NEQUAL               : 80 81 82 83 89 95 101 107 113
PLUS                 : 13 14 15 16
PRINT                : 127
READ                 : 126
REPEAT               : 125
RETURN               : 43 44 45 46
RPAREN               : 126 127 128 129 130 131
TIMES                : 21 22 23 24
TRUE                 : 40 57
UNTIL                : 125
WHILE                : 116
error                : 

Nonterminals, with rules where they appear

add                  : 7
ar_op                : 39 45 47 84 84 85 85 86 86 87 87 88 88 89 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 136
attr                 : 48
cond                 : 114 115 116
cond_op              : 59 125
div                  : 10
for                  : 56
func                 : 5 6
func_call            : 42 46 51 137
func_l_op            : 1 6
if                   : 54
l_a_param            : 127 130 138 139
l_op                 : 1 2 4 114 115 115 116 117 118 119 120 121 122 123 124 125 128 129
l_param              : 126 128 133
mod                  : 12
mul                  : 8
op                   : 3 4
program              : 0
rdiv                 : 11
read                 : 50
repeat               : 52
ret_op               : 53
sub                  : 9
while                : 55
write                : 49

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . func_l_op l_op
    (2) program -> . l_op
    (5) func_l_op -> . func
    (6) func_l_op -> . func func_l_op
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (128) func -> . FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION
    (129) func -> . FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    FUNCTION        shift and go to state 6
    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    program                        shift and go to state 1
    func_l_op                      shift and go to state 2
    l_op                           shift and go to state 3
    func                           shift and go to state 4
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 1

    (0) S' -> program .



state 2

    (1) program -> func_l_op . l_op
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 32
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 3

    (2) program -> l_op .

    $end            reduce using rule 2 (program -> l_op .)


state 4

    (5) func_l_op -> func .
    (6) func_l_op -> func . func_l_op
    (5) func_l_op -> . func
    (6) func_l_op -> . func func_l_op
    (128) func -> . FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION
    (129) func -> . FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION

    ID              reduce using rule 5 (func_l_op -> func .)
    PRINT           reduce using rule 5 (func_l_op -> func .)
    READ            reduce using rule 5 (func_l_op -> func .)
    REPEAT          reduce using rule 5 (func_l_op -> func .)
    RETURN          reduce using rule 5 (func_l_op -> func .)
    IF              reduce using rule 5 (func_l_op -> func .)
    WHILE           reduce using rule 5 (func_l_op -> func .)
    FOR             reduce using rule 5 (func_l_op -> func .)
    CONST           reduce using rule 5 (func_l_op -> func .)
    FUNCTION        shift and go to state 6

    func                           shift and go to state 4
    func_l_op                      shift and go to state 33

state 5

    (3) l_op -> op .
    (4) l_op -> op . l_op
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    $end            reduce using rule 3 (l_op -> op .)
    UNTIL           reduce using rule 3 (l_op -> op .)
    ENDIF           reduce using rule 3 (l_op -> op .)
    ELSE            reduce using rule 3 (l_op -> op .)
    ENDWHILE        reduce using rule 3 (l_op -> op .)
    ENDFUNCTION     reduce using rule 3 (l_op -> op .)
    ENDFOR          reduce using rule 3 (l_op -> op .)
    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    op                             shift and go to state 5
    l_op                           shift and go to state 34
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 6

    (128) func -> FUNCTION . ID LPAREN l_param RPAREN l_op ENDFUNCTION
    (129) func -> FUNCTION . ID LPAREN RPAREN l_op ENDFUNCTION

    ID              shift and go to state 35


state 7

    (37) attr -> ID . ASSIGN ID
    (38) attr -> ID . ASSIGN CONST
    (39) attr -> ID . ASSIGN ar_op
    (40) attr -> ID . ASSIGN TRUE
    (41) attr -> ID . ASSIGN FALSE
    (42) attr -> ID . ASSIGN func_call
    (130) func_call -> ID . LPAREN l_a_param RPAREN
    (131) func_call -> ID . LPAREN RPAREN
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ASSIGN          shift and go to state 36
    LPAREN          shift and go to state 37
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 8

    (47) op -> ar_op .

    ID              reduce using rule 47 (op -> ar_op .)
    PRINT           reduce using rule 47 (op -> ar_op .)
    READ            reduce using rule 47 (op -> ar_op .)
    REPEAT          reduce using rule 47 (op -> ar_op .)
    RETURN          reduce using rule 47 (op -> ar_op .)
    IF              reduce using rule 47 (op -> ar_op .)
    WHILE           reduce using rule 47 (op -> ar_op .)
    FOR             reduce using rule 47 (op -> ar_op .)
    CONST           reduce using rule 47 (op -> ar_op .)
    $end            reduce using rule 47 (op -> ar_op .)
    UNTIL           reduce using rule 47 (op -> ar_op .)
    ENDIF           reduce using rule 47 (op -> ar_op .)
    ELSE            reduce using rule 47 (op -> ar_op .)
    ENDWHILE        reduce using rule 47 (op -> ar_op .)
    ENDFUNCTION     reduce using rule 47 (op -> ar_op .)
    ENDFOR          reduce using rule 47 (op -> ar_op .)


state 9

    (48) op -> attr .

    ID              reduce using rule 48 (op -> attr .)
    PRINT           reduce using rule 48 (op -> attr .)
    READ            reduce using rule 48 (op -> attr .)
    REPEAT          reduce using rule 48 (op -> attr .)
    RETURN          reduce using rule 48 (op -> attr .)
    IF              reduce using rule 48 (op -> attr .)
    WHILE           reduce using rule 48 (op -> attr .)
    FOR             reduce using rule 48 (op -> attr .)
    CONST           reduce using rule 48 (op -> attr .)
    $end            reduce using rule 48 (op -> attr .)
    UNTIL           reduce using rule 48 (op -> attr .)
    ENDIF           reduce using rule 48 (op -> attr .)
    ELSE            reduce using rule 48 (op -> attr .)
    ENDWHILE        reduce using rule 48 (op -> attr .)
    ENDFUNCTION     reduce using rule 48 (op -> attr .)
    ENDFOR          reduce using rule 48 (op -> attr .)


state 10

    (49) op -> write .

    ID              reduce using rule 49 (op -> write .)
    PRINT           reduce using rule 49 (op -> write .)
    READ            reduce using rule 49 (op -> write .)
    REPEAT          reduce using rule 49 (op -> write .)
    RETURN          reduce using rule 49 (op -> write .)
    IF              reduce using rule 49 (op -> write .)
    WHILE           reduce using rule 49 (op -> write .)
    FOR             reduce using rule 49 (op -> write .)
    CONST           reduce using rule 49 (op -> write .)
    $end            reduce using rule 49 (op -> write .)
    UNTIL           reduce using rule 49 (op -> write .)
    ENDIF           reduce using rule 49 (op -> write .)
    ELSE            reduce using rule 49 (op -> write .)
    ENDWHILE        reduce using rule 49 (op -> write .)
    ENDFUNCTION     reduce using rule 49 (op -> write .)
    ENDFOR          reduce using rule 49 (op -> write .)


state 11

    (50) op -> read .

    ID              reduce using rule 50 (op -> read .)
    PRINT           reduce using rule 50 (op -> read .)
    READ            reduce using rule 50 (op -> read .)
    REPEAT          reduce using rule 50 (op -> read .)
    RETURN          reduce using rule 50 (op -> read .)
    IF              reduce using rule 50 (op -> read .)
    WHILE           reduce using rule 50 (op -> read .)
    FOR             reduce using rule 50 (op -> read .)
    CONST           reduce using rule 50 (op -> read .)
    $end            reduce using rule 50 (op -> read .)
    UNTIL           reduce using rule 50 (op -> read .)
    ENDIF           reduce using rule 50 (op -> read .)
    ELSE            reduce using rule 50 (op -> read .)
    ENDWHILE        reduce using rule 50 (op -> read .)
    ENDFUNCTION     reduce using rule 50 (op -> read .)
    ENDFOR          reduce using rule 50 (op -> read .)


state 12

    (51) op -> func_call .

    ID              reduce using rule 51 (op -> func_call .)
    PRINT           reduce using rule 51 (op -> func_call .)
    READ            reduce using rule 51 (op -> func_call .)
    REPEAT          reduce using rule 51 (op -> func_call .)
    RETURN          reduce using rule 51 (op -> func_call .)
    IF              reduce using rule 51 (op -> func_call .)
    WHILE           reduce using rule 51 (op -> func_call .)
    FOR             reduce using rule 51 (op -> func_call .)
    CONST           reduce using rule 51 (op -> func_call .)
    $end            reduce using rule 51 (op -> func_call .)
    UNTIL           reduce using rule 51 (op -> func_call .)
    ENDIF           reduce using rule 51 (op -> func_call .)
    ELSE            reduce using rule 51 (op -> func_call .)
    ENDWHILE        reduce using rule 51 (op -> func_call .)
    ENDFUNCTION     reduce using rule 51 (op -> func_call .)
    ENDFOR          reduce using rule 51 (op -> func_call .)


state 13

    (52) op -> repeat .

    ID              reduce using rule 52 (op -> repeat .)
    PRINT           reduce using rule 52 (op -> repeat .)
    READ            reduce using rule 52 (op -> repeat .)
    REPEAT          reduce using rule 52 (op -> repeat .)
    RETURN          reduce using rule 52 (op -> repeat .)
    IF              reduce using rule 52 (op -> repeat .)
    WHILE           reduce using rule 52 (op -> repeat .)
    FOR             reduce using rule 52 (op -> repeat .)
    CONST           reduce using rule 52 (op -> repeat .)
    $end            reduce using rule 52 (op -> repeat .)
    UNTIL           reduce using rule 52 (op -> repeat .)
    ENDIF           reduce using rule 52 (op -> repeat .)
    ELSE            reduce using rule 52 (op -> repeat .)
    ENDWHILE        reduce using rule 52 (op -> repeat .)
    ENDFUNCTION     reduce using rule 52 (op -> repeat .)
    ENDFOR          reduce using rule 52 (op -> repeat .)


state 14

    (53) op -> ret_op .

    ID              reduce using rule 53 (op -> ret_op .)
    PRINT           reduce using rule 53 (op -> ret_op .)
    READ            reduce using rule 53 (op -> ret_op .)
    REPEAT          reduce using rule 53 (op -> ret_op .)
    RETURN          reduce using rule 53 (op -> ret_op .)
    IF              reduce using rule 53 (op -> ret_op .)
    WHILE           reduce using rule 53 (op -> ret_op .)
    FOR             reduce using rule 53 (op -> ret_op .)
    CONST           reduce using rule 53 (op -> ret_op .)
    $end            reduce using rule 53 (op -> ret_op .)
    UNTIL           reduce using rule 53 (op -> ret_op .)
    ENDIF           reduce using rule 53 (op -> ret_op .)
    ELSE            reduce using rule 53 (op -> ret_op .)
    ENDWHILE        reduce using rule 53 (op -> ret_op .)
    ENDFUNCTION     reduce using rule 53 (op -> ret_op .)
    ENDFOR          reduce using rule 53 (op -> ret_op .)


state 15

    (54) op -> if .

    ID              reduce using rule 54 (op -> if .)
    PRINT           reduce using rule 54 (op -> if .)
    READ            reduce using rule 54 (op -> if .)
    REPEAT          reduce using rule 54 (op -> if .)
    RETURN          reduce using rule 54 (op -> if .)
    IF              reduce using rule 54 (op -> if .)
    WHILE           reduce using rule 54 (op -> if .)
    FOR             reduce using rule 54 (op -> if .)
    CONST           reduce using rule 54 (op -> if .)
    $end            reduce using rule 54 (op -> if .)
    UNTIL           reduce using rule 54 (op -> if .)
    ENDIF           reduce using rule 54 (op -> if .)
    ELSE            reduce using rule 54 (op -> if .)
    ENDWHILE        reduce using rule 54 (op -> if .)
    ENDFUNCTION     reduce using rule 54 (op -> if .)
    ENDFOR          reduce using rule 54 (op -> if .)


state 16

    (55) op -> while .

    ID              reduce using rule 55 (op -> while .)
    PRINT           reduce using rule 55 (op -> while .)
    READ            reduce using rule 55 (op -> while .)
    REPEAT          reduce using rule 55 (op -> while .)
    RETURN          reduce using rule 55 (op -> while .)
    IF              reduce using rule 55 (op -> while .)
    WHILE           reduce using rule 55 (op -> while .)
    FOR             reduce using rule 55 (op -> while .)
    CONST           reduce using rule 55 (op -> while .)
    $end            reduce using rule 55 (op -> while .)
    UNTIL           reduce using rule 55 (op -> while .)
    ENDIF           reduce using rule 55 (op -> while .)
    ELSE            reduce using rule 55 (op -> while .)
    ENDWHILE        reduce using rule 55 (op -> while .)
    ENDFUNCTION     reduce using rule 55 (op -> while .)
    ENDFOR          reduce using rule 55 (op -> while .)


state 17

    (56) op -> for .

    ID              reduce using rule 56 (op -> for .)
    PRINT           reduce using rule 56 (op -> for .)
    READ            reduce using rule 56 (op -> for .)
    REPEAT          reduce using rule 56 (op -> for .)
    RETURN          reduce using rule 56 (op -> for .)
    IF              reduce using rule 56 (op -> for .)
    WHILE           reduce using rule 56 (op -> for .)
    FOR             reduce using rule 56 (op -> for .)
    CONST           reduce using rule 56 (op -> for .)
    $end            reduce using rule 56 (op -> for .)
    UNTIL           reduce using rule 56 (op -> for .)
    ENDIF           reduce using rule 56 (op -> for .)
    ELSE            reduce using rule 56 (op -> for .)
    ENDWHILE        reduce using rule 56 (op -> for .)
    ENDFUNCTION     reduce using rule 56 (op -> for .)
    ENDFOR          reduce using rule 56 (op -> for .)


state 18

    (7) ar_op -> add .

    ID              reduce using rule 7 (ar_op -> add .)
    PRINT           reduce using rule 7 (ar_op -> add .)
    READ            reduce using rule 7 (ar_op -> add .)
    REPEAT          reduce using rule 7 (ar_op -> add .)
    RETURN          reduce using rule 7 (ar_op -> add .)
    IF              reduce using rule 7 (ar_op -> add .)
    WHILE           reduce using rule 7 (ar_op -> add .)
    FOR             reduce using rule 7 (ar_op -> add .)
    CONST           reduce using rule 7 (ar_op -> add .)
    $end            reduce using rule 7 (ar_op -> add .)
    UNTIL           reduce using rule 7 (ar_op -> add .)
    ENDIF           reduce using rule 7 (ar_op -> add .)
    ELSE            reduce using rule 7 (ar_op -> add .)
    ENDWHILE        reduce using rule 7 (ar_op -> add .)
    ENDFUNCTION     reduce using rule 7 (ar_op -> add .)
    ENDFOR          reduce using rule 7 (ar_op -> add .)
    LOWER           reduce using rule 7 (ar_op -> add .)
    GREATER         reduce using rule 7 (ar_op -> add .)
    LEQUAL          reduce using rule 7 (ar_op -> add .)
    GEQUAL          reduce using rule 7 (ar_op -> add .)
    EQUAL           reduce using rule 7 (ar_op -> add .)
    NEQUAL          reduce using rule 7 (ar_op -> add .)
    RPAREN          reduce using rule 7 (ar_op -> add .)
    COMMA           reduce using rule 7 (ar_op -> add .)
    ATUNCI          reduce using rule 7 (ar_op -> add .)
    EXECUTA         reduce using rule 7 (ar_op -> add .)


state 19

    (8) ar_op -> mul .

    ID              reduce using rule 8 (ar_op -> mul .)
    PRINT           reduce using rule 8 (ar_op -> mul .)
    READ            reduce using rule 8 (ar_op -> mul .)
    REPEAT          reduce using rule 8 (ar_op -> mul .)
    RETURN          reduce using rule 8 (ar_op -> mul .)
    IF              reduce using rule 8 (ar_op -> mul .)
    WHILE           reduce using rule 8 (ar_op -> mul .)
    FOR             reduce using rule 8 (ar_op -> mul .)
    CONST           reduce using rule 8 (ar_op -> mul .)
    $end            reduce using rule 8 (ar_op -> mul .)
    UNTIL           reduce using rule 8 (ar_op -> mul .)
    ENDIF           reduce using rule 8 (ar_op -> mul .)
    ELSE            reduce using rule 8 (ar_op -> mul .)
    ENDWHILE        reduce using rule 8 (ar_op -> mul .)
    ENDFUNCTION     reduce using rule 8 (ar_op -> mul .)
    ENDFOR          reduce using rule 8 (ar_op -> mul .)
    LOWER           reduce using rule 8 (ar_op -> mul .)
    GREATER         reduce using rule 8 (ar_op -> mul .)
    LEQUAL          reduce using rule 8 (ar_op -> mul .)
    GEQUAL          reduce using rule 8 (ar_op -> mul .)
    EQUAL           reduce using rule 8 (ar_op -> mul .)
    NEQUAL          reduce using rule 8 (ar_op -> mul .)
    RPAREN          reduce using rule 8 (ar_op -> mul .)
    COMMA           reduce using rule 8 (ar_op -> mul .)
    ATUNCI          reduce using rule 8 (ar_op -> mul .)
    EXECUTA         reduce using rule 8 (ar_op -> mul .)


state 20

    (9) ar_op -> sub .

    ID              reduce using rule 9 (ar_op -> sub .)
    PRINT           reduce using rule 9 (ar_op -> sub .)
    READ            reduce using rule 9 (ar_op -> sub .)
    REPEAT          reduce using rule 9 (ar_op -> sub .)
    RETURN          reduce using rule 9 (ar_op -> sub .)
    IF              reduce using rule 9 (ar_op -> sub .)
    WHILE           reduce using rule 9 (ar_op -> sub .)
    FOR             reduce using rule 9 (ar_op -> sub .)
    CONST           reduce using rule 9 (ar_op -> sub .)
    $end            reduce using rule 9 (ar_op -> sub .)
    UNTIL           reduce using rule 9 (ar_op -> sub .)
    ENDIF           reduce using rule 9 (ar_op -> sub .)
    ELSE            reduce using rule 9 (ar_op -> sub .)
    ENDWHILE        reduce using rule 9 (ar_op -> sub .)
    ENDFUNCTION     reduce using rule 9 (ar_op -> sub .)
    ENDFOR          reduce using rule 9 (ar_op -> sub .)
    LOWER           reduce using rule 9 (ar_op -> sub .)
    GREATER         reduce using rule 9 (ar_op -> sub .)
    LEQUAL          reduce using rule 9 (ar_op -> sub .)
    GEQUAL          reduce using rule 9 (ar_op -> sub .)
    EQUAL           reduce using rule 9 (ar_op -> sub .)
    NEQUAL          reduce using rule 9 (ar_op -> sub .)
    RPAREN          reduce using rule 9 (ar_op -> sub .)
    COMMA           reduce using rule 9 (ar_op -> sub .)
    ATUNCI          reduce using rule 9 (ar_op -> sub .)
    EXECUTA         reduce using rule 9 (ar_op -> sub .)


state 21

    (10) ar_op -> div .

    ID              reduce using rule 10 (ar_op -> div .)
    PRINT           reduce using rule 10 (ar_op -> div .)
    READ            reduce using rule 10 (ar_op -> div .)
    REPEAT          reduce using rule 10 (ar_op -> div .)
    RETURN          reduce using rule 10 (ar_op -> div .)
    IF              reduce using rule 10 (ar_op -> div .)
    WHILE           reduce using rule 10 (ar_op -> div .)
    FOR             reduce using rule 10 (ar_op -> div .)
    CONST           reduce using rule 10 (ar_op -> div .)
    $end            reduce using rule 10 (ar_op -> div .)
    UNTIL           reduce using rule 10 (ar_op -> div .)
    ENDIF           reduce using rule 10 (ar_op -> div .)
    ELSE            reduce using rule 10 (ar_op -> div .)
    ENDWHILE        reduce using rule 10 (ar_op -> div .)
    ENDFUNCTION     reduce using rule 10 (ar_op -> div .)
    ENDFOR          reduce using rule 10 (ar_op -> div .)
    LOWER           reduce using rule 10 (ar_op -> div .)
    GREATER         reduce using rule 10 (ar_op -> div .)
    LEQUAL          reduce using rule 10 (ar_op -> div .)
    GEQUAL          reduce using rule 10 (ar_op -> div .)
    EQUAL           reduce using rule 10 (ar_op -> div .)
    NEQUAL          reduce using rule 10 (ar_op -> div .)
    RPAREN          reduce using rule 10 (ar_op -> div .)
    COMMA           reduce using rule 10 (ar_op -> div .)
    ATUNCI          reduce using rule 10 (ar_op -> div .)
    EXECUTA         reduce using rule 10 (ar_op -> div .)


state 22

    (11) ar_op -> rdiv .

    ID              reduce using rule 11 (ar_op -> rdiv .)
    PRINT           reduce using rule 11 (ar_op -> rdiv .)
    READ            reduce using rule 11 (ar_op -> rdiv .)
    REPEAT          reduce using rule 11 (ar_op -> rdiv .)
    RETURN          reduce using rule 11 (ar_op -> rdiv .)
    IF              reduce using rule 11 (ar_op -> rdiv .)
    WHILE           reduce using rule 11 (ar_op -> rdiv .)
    FOR             reduce using rule 11 (ar_op -> rdiv .)
    CONST           reduce using rule 11 (ar_op -> rdiv .)
    $end            reduce using rule 11 (ar_op -> rdiv .)
    UNTIL           reduce using rule 11 (ar_op -> rdiv .)
    ENDIF           reduce using rule 11 (ar_op -> rdiv .)
    ELSE            reduce using rule 11 (ar_op -> rdiv .)
    ENDWHILE        reduce using rule 11 (ar_op -> rdiv .)
    ENDFUNCTION     reduce using rule 11 (ar_op -> rdiv .)
    ENDFOR          reduce using rule 11 (ar_op -> rdiv .)
    LOWER           reduce using rule 11 (ar_op -> rdiv .)
    GREATER         reduce using rule 11 (ar_op -> rdiv .)
    LEQUAL          reduce using rule 11 (ar_op -> rdiv .)
    GEQUAL          reduce using rule 11 (ar_op -> rdiv .)
    EQUAL           reduce using rule 11 (ar_op -> rdiv .)
    NEQUAL          reduce using rule 11 (ar_op -> rdiv .)
    RPAREN          reduce using rule 11 (ar_op -> rdiv .)
    COMMA           reduce using rule 11 (ar_op -> rdiv .)
    ATUNCI          reduce using rule 11 (ar_op -> rdiv .)
    EXECUTA         reduce using rule 11 (ar_op -> rdiv .)


state 23

    (12) ar_op -> mod .

    ID              reduce using rule 12 (ar_op -> mod .)
    PRINT           reduce using rule 12 (ar_op -> mod .)
    READ            reduce using rule 12 (ar_op -> mod .)
    REPEAT          reduce using rule 12 (ar_op -> mod .)
    RETURN          reduce using rule 12 (ar_op -> mod .)
    IF              reduce using rule 12 (ar_op -> mod .)
    WHILE           reduce using rule 12 (ar_op -> mod .)
    FOR             reduce using rule 12 (ar_op -> mod .)
    CONST           reduce using rule 12 (ar_op -> mod .)
    $end            reduce using rule 12 (ar_op -> mod .)
    UNTIL           reduce using rule 12 (ar_op -> mod .)
    ENDIF           reduce using rule 12 (ar_op -> mod .)
    ELSE            reduce using rule 12 (ar_op -> mod .)
    ENDWHILE        reduce using rule 12 (ar_op -> mod .)
    ENDFUNCTION     reduce using rule 12 (ar_op -> mod .)
    ENDFOR          reduce using rule 12 (ar_op -> mod .)
    LOWER           reduce using rule 12 (ar_op -> mod .)
    GREATER         reduce using rule 12 (ar_op -> mod .)
    LEQUAL          reduce using rule 12 (ar_op -> mod .)
    GEQUAL          reduce using rule 12 (ar_op -> mod .)
    EQUAL           reduce using rule 12 (ar_op -> mod .)
    NEQUAL          reduce using rule 12 (ar_op -> mod .)
    RPAREN          reduce using rule 12 (ar_op -> mod .)
    COMMA           reduce using rule 12 (ar_op -> mod .)
    ATUNCI          reduce using rule 12 (ar_op -> mod .)
    EXECUTA         reduce using rule 12 (ar_op -> mod .)


state 24

    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 25

    (127) write -> PRINT . LPAREN l_a_param RPAREN

    LPAREN          shift and go to state 50


state 26

    (126) read -> READ . LPAREN l_param RPAREN

    LPAREN          shift and go to state 51


state 27

    (125) repeat -> REPEAT . l_op UNTIL cond_op
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 52
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 28

    (43) ret_op -> RETURN . ID
    (44) ret_op -> RETURN . CONST
    (45) ret_op -> RETURN . ar_op
    (46) ret_op -> RETURN . func_call
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 53
    CONST           shift and go to state 54

    ar_op                          shift and go to state 55
    func_call                      shift and go to state 56
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 29

    (114) if -> IF . cond ATUNCI l_op ENDIF
    (115) if -> IF . cond ATUNCI l_op ELSE l_op ENDIF
    (57) cond -> . TRUE
    (58) cond -> . FALSE
    (59) cond -> . cond_op
    (60) cond_op -> . ID LOWER ID
    (61) cond_op -> . ID LOWER CONST
    (62) cond_op -> . CONST LOWER ID
    (63) cond_op -> . CONST LOWER CONST
    (64) cond_op -> . ID GREATER ID
    (65) cond_op -> . ID GREATER CONST
    (66) cond_op -> . CONST GREATER ID
    (67) cond_op -> . CONST GREATER CONST
    (68) cond_op -> . ID LEQUAL ID
    (69) cond_op -> . ID LEQUAL CONST
    (70) cond_op -> . CONST LEQUAL ID
    (71) cond_op -> . CONST LEQUAL CONST
    (72) cond_op -> . ID GEQUAL ID
    (73) cond_op -> . ID GEQUAL CONST
    (74) cond_op -> . CONST GEQUAL ID
    (75) cond_op -> . CONST GEQUAL CONST
    (76) cond_op -> . ID EQUAL ID
    (77) cond_op -> . ID EQUAL CONST
    (78) cond_op -> . CONST EQUAL ID
    (79) cond_op -> . CONST EQUAL CONST
    (80) cond_op -> . ID NEQUAL ID
    (81) cond_op -> . ID NEQUAL CONST
    (82) cond_op -> . CONST NEQUAL ID
    (83) cond_op -> . CONST NEQUAL CONST
    (84) cond_op -> . ar_op LOWER ar_op
    (85) cond_op -> . ar_op GREATER ar_op
    (86) cond_op -> . ar_op LEQUAL ar_op
    (87) cond_op -> . ar_op GEQUAL ar_op
    (88) cond_op -> . ar_op EQUAL ar_op
    (89) cond_op -> . ar_op NEQUAL ar_op
    (90) cond_op -> . ar_op LOWER ID
    (91) cond_op -> . ar_op GREATER ID
    (92) cond_op -> . ar_op LEQUAL ID
    (93) cond_op -> . ar_op GEQUAL ID
    (94) cond_op -> . ar_op EQUAL ID
    (95) cond_op -> . ar_op NEQUAL ID
    (96) cond_op -> . ID LOWER ar_op
    (97) cond_op -> . ID GREATER ar_op
    (98) cond_op -> . ID LEQUAL ar_op
    (99) cond_op -> . ID GEQUAL ar_op
    (100) cond_op -> . ID EQUAL ar_op
    (101) cond_op -> . ID NEQUAL ar_op
    (102) cond_op -> . ar_op LOWER CONST
    (103) cond_op -> . ar_op GREATER CONST
    (104) cond_op -> . ar_op LEQUAL CONST
    (105) cond_op -> . ar_op GEQUAL CONST
    (106) cond_op -> . ar_op EQUAL CONST
    (107) cond_op -> . ar_op NEQUAL CONST
    (108) cond_op -> . CONST LOWER ar_op
    (109) cond_op -> . CONST GREATER ar_op
    (110) cond_op -> . CONST LEQUAL ar_op
    (111) cond_op -> . CONST GEQUAL ar_op
    (112) cond_op -> . CONST EQUAL ar_op
    (113) cond_op -> . CONST NEQUAL ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    ID              shift and go to state 61
    CONST           shift and go to state 62

    cond                           shift and go to state 57
    cond_op                        shift and go to state 60
    ar_op                          shift and go to state 63
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 30

    (116) while -> WHILE . cond EXECUTA l_op ENDWHILE
    (57) cond -> . TRUE
    (58) cond -> . FALSE
    (59) cond -> . cond_op
    (60) cond_op -> . ID LOWER ID
    (61) cond_op -> . ID LOWER CONST
    (62) cond_op -> . CONST LOWER ID
    (63) cond_op -> . CONST LOWER CONST
    (64) cond_op -> . ID GREATER ID
    (65) cond_op -> . ID GREATER CONST
    (66) cond_op -> . CONST GREATER ID
    (67) cond_op -> . CONST GREATER CONST
    (68) cond_op -> . ID LEQUAL ID
    (69) cond_op -> . ID LEQUAL CONST
    (70) cond_op -> . CONST LEQUAL ID
    (71) cond_op -> . CONST LEQUAL CONST
    (72) cond_op -> . ID GEQUAL ID
    (73) cond_op -> . ID GEQUAL CONST
    (74) cond_op -> . CONST GEQUAL ID
    (75) cond_op -> . CONST GEQUAL CONST
    (76) cond_op -> . ID EQUAL ID
    (77) cond_op -> . ID EQUAL CONST
    (78) cond_op -> . CONST EQUAL ID
    (79) cond_op -> . CONST EQUAL CONST
    (80) cond_op -> . ID NEQUAL ID
    (81) cond_op -> . ID NEQUAL CONST
    (82) cond_op -> . CONST NEQUAL ID
    (83) cond_op -> . CONST NEQUAL CONST
    (84) cond_op -> . ar_op LOWER ar_op
    (85) cond_op -> . ar_op GREATER ar_op
    (86) cond_op -> . ar_op LEQUAL ar_op
    (87) cond_op -> . ar_op GEQUAL ar_op
    (88) cond_op -> . ar_op EQUAL ar_op
    (89) cond_op -> . ar_op NEQUAL ar_op
    (90) cond_op -> . ar_op LOWER ID
    (91) cond_op -> . ar_op GREATER ID
    (92) cond_op -> . ar_op LEQUAL ID
    (93) cond_op -> . ar_op GEQUAL ID
    (94) cond_op -> . ar_op EQUAL ID
    (95) cond_op -> . ar_op NEQUAL ID
    (96) cond_op -> . ID LOWER ar_op
    (97) cond_op -> . ID GREATER ar_op
    (98) cond_op -> . ID LEQUAL ar_op
    (99) cond_op -> . ID GEQUAL ar_op
    (100) cond_op -> . ID EQUAL ar_op
    (101) cond_op -> . ID NEQUAL ar_op
    (102) cond_op -> . ar_op LOWER CONST
    (103) cond_op -> . ar_op GREATER CONST
    (104) cond_op -> . ar_op LEQUAL CONST
    (105) cond_op -> . ar_op GEQUAL CONST
    (106) cond_op -> . ar_op EQUAL CONST
    (107) cond_op -> . ar_op NEQUAL CONST
    (108) cond_op -> . CONST LOWER ar_op
    (109) cond_op -> . CONST GREATER ar_op
    (110) cond_op -> . CONST LEQUAL ar_op
    (111) cond_op -> . CONST GEQUAL ar_op
    (112) cond_op -> . CONST EQUAL ar_op
    (113) cond_op -> . CONST NEQUAL ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    TRUE            shift and go to state 58
    FALSE           shift and go to state 59
    ID              shift and go to state 61
    CONST           shift and go to state 62

    cond                           shift and go to state 64
    cond_op                        shift and go to state 60
    ar_op                          shift and go to state 63
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 31

    (117) for -> FOR . ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> FOR . ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> FOR . ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> FOR . ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> FOR . ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> FOR . ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> FOR . ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> FOR . ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR

    ID              shift and go to state 65


state 32

    (1) program -> func_l_op l_op .

    $end            reduce using rule 1 (program -> func_l_op l_op .)


state 33

    (6) func_l_op -> func func_l_op .

    ID              reduce using rule 6 (func_l_op -> func func_l_op .)
    PRINT           reduce using rule 6 (func_l_op -> func func_l_op .)
    READ            reduce using rule 6 (func_l_op -> func func_l_op .)
    REPEAT          reduce using rule 6 (func_l_op -> func func_l_op .)
    RETURN          reduce using rule 6 (func_l_op -> func func_l_op .)
    IF              reduce using rule 6 (func_l_op -> func func_l_op .)
    WHILE           reduce using rule 6 (func_l_op -> func func_l_op .)
    FOR             reduce using rule 6 (func_l_op -> func func_l_op .)
    CONST           reduce using rule 6 (func_l_op -> func func_l_op .)


state 34

    (4) l_op -> op l_op .

    $end            reduce using rule 4 (l_op -> op l_op .)
    UNTIL           reduce using rule 4 (l_op -> op l_op .)
    ENDIF           reduce using rule 4 (l_op -> op l_op .)
    ELSE            reduce using rule 4 (l_op -> op l_op .)
    ENDWHILE        reduce using rule 4 (l_op -> op l_op .)
    ENDFUNCTION     reduce using rule 4 (l_op -> op l_op .)
    ENDFOR          reduce using rule 4 (l_op -> op l_op .)


state 35

    (128) func -> FUNCTION ID . LPAREN l_param RPAREN l_op ENDFUNCTION
    (129) func -> FUNCTION ID . LPAREN RPAREN l_op ENDFUNCTION

    LPAREN          shift and go to state 66


state 36

    (37) attr -> ID ASSIGN . ID
    (38) attr -> ID ASSIGN . CONST
    (39) attr -> ID ASSIGN . ar_op
    (40) attr -> ID ASSIGN . TRUE
    (41) attr -> ID ASSIGN . FALSE
    (42) attr -> ID ASSIGN . func_call
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 67
    CONST           shift and go to state 68
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    ar_op                          shift and go to state 69
    func_call                      shift and go to state 72
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 37

    (130) func_call -> ID LPAREN . l_a_param RPAREN
    (131) func_call -> ID LPAREN . RPAREN
    (134) l_a_param -> . CONST
    (135) l_a_param -> . ID
    (136) l_a_param -> . ar_op
    (137) l_a_param -> . func_call
    (138) l_a_param -> . l_a_param COMMA CONST
    (139) l_a_param -> . l_a_param COMMA ID
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    RPAREN          shift and go to state 75
    CONST           shift and go to state 76
    ID              shift and go to state 73

    l_a_param                      shift and go to state 74
    ar_op                          shift and go to state 77
    func_call                      shift and go to state 78
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 38

    (13) add -> ID PLUS . ID
    (15) add -> ID PLUS . CONST

    ID              shift and go to state 79
    CONST           shift and go to state 80


state 39

    (21) mul -> ID TIMES . ID
    (23) mul -> ID TIMES . CONST

    ID              shift and go to state 81
    CONST           shift and go to state 82


state 40

    (17) sub -> ID MINUS . ID
    (19) sub -> ID MINUS . CONST

    ID              shift and go to state 83
    CONST           shift and go to state 84


state 41

    (25) div -> ID DIV . ID
    (27) div -> ID DIV . CONST

    ID              shift and go to state 85
    CONST           shift and go to state 86


state 42

    (29) rdiv -> ID DIVIDE . ID
    (31) rdiv -> ID DIVIDE . CONST

    ID              shift and go to state 87
    CONST           shift and go to state 88


state 43

    (33) mod -> ID MOD . ID
    (35) mod -> ID MOD . CONST

    ID              shift and go to state 89
    CONST           shift and go to state 90


state 44

    (14) add -> CONST PLUS . ID
    (16) add -> CONST PLUS . CONST

    ID              shift and go to state 92
    CONST           shift and go to state 91


state 45

    (22) mul -> CONST TIMES . ID
    (24) mul -> CONST TIMES . CONST

    ID              shift and go to state 94
    CONST           shift and go to state 93


state 46

    (18) sub -> CONST MINUS . ID
    (20) sub -> CONST MINUS . CONST

    ID              shift and go to state 96
    CONST           shift and go to state 95


state 47

    (26) div -> CONST DIV . ID
    (28) div -> CONST DIV . CONST

    ID              shift and go to state 98
    CONST           shift and go to state 97


state 48

    (30) rdiv -> CONST DIVIDE . ID
    (32) rdiv -> CONST DIVIDE . CONST

    ID              shift and go to state 100
    CONST           shift and go to state 99


state 49

    (34) mod -> CONST MOD . ID
    (36) mod -> CONST MOD . CONST

    ID              shift and go to state 102
    CONST           shift and go to state 101


state 50

    (127) write -> PRINT LPAREN . l_a_param RPAREN
    (134) l_a_param -> . CONST
    (135) l_a_param -> . ID
    (136) l_a_param -> . ar_op
    (137) l_a_param -> . func_call
    (138) l_a_param -> . l_a_param COMMA CONST
    (139) l_a_param -> . l_a_param COMMA ID
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    CONST           shift and go to state 76
    ID              shift and go to state 73

    l_a_param                      shift and go to state 103
    ar_op                          shift and go to state 77
    func_call                      shift and go to state 78
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 51

    (126) read -> READ LPAREN . l_param RPAREN
    (132) l_param -> . ID
    (133) l_param -> . ID COMMA l_param

    ID              shift and go to state 105

    l_param                        shift and go to state 104

state 52

    (125) repeat -> REPEAT l_op . UNTIL cond_op

    UNTIL           shift and go to state 106


state 53

    (43) ret_op -> RETURN ID .
    (130) func_call -> ID . LPAREN l_a_param RPAREN
    (131) func_call -> ID . LPAREN RPAREN
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ID              reduce using rule 43 (ret_op -> RETURN ID .)
    PRINT           reduce using rule 43 (ret_op -> RETURN ID .)
    READ            reduce using rule 43 (ret_op -> RETURN ID .)
    REPEAT          reduce using rule 43 (ret_op -> RETURN ID .)
    RETURN          reduce using rule 43 (ret_op -> RETURN ID .)
    IF              reduce using rule 43 (ret_op -> RETURN ID .)
    WHILE           reduce using rule 43 (ret_op -> RETURN ID .)
    FOR             reduce using rule 43 (ret_op -> RETURN ID .)
    CONST           reduce using rule 43 (ret_op -> RETURN ID .)
    $end            reduce using rule 43 (ret_op -> RETURN ID .)
    UNTIL           reduce using rule 43 (ret_op -> RETURN ID .)
    ENDIF           reduce using rule 43 (ret_op -> RETURN ID .)
    ELSE            reduce using rule 43 (ret_op -> RETURN ID .)
    ENDWHILE        reduce using rule 43 (ret_op -> RETURN ID .)
    ENDFUNCTION     reduce using rule 43 (ret_op -> RETURN ID .)
    ENDFOR          reduce using rule 43 (ret_op -> RETURN ID .)
    LPAREN          shift and go to state 37
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 54

    (44) ret_op -> RETURN CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ID              reduce using rule 44 (ret_op -> RETURN CONST .)
    PRINT           reduce using rule 44 (ret_op -> RETURN CONST .)
    READ            reduce using rule 44 (ret_op -> RETURN CONST .)
    REPEAT          reduce using rule 44 (ret_op -> RETURN CONST .)
    RETURN          reduce using rule 44 (ret_op -> RETURN CONST .)
    IF              reduce using rule 44 (ret_op -> RETURN CONST .)
    WHILE           reduce using rule 44 (ret_op -> RETURN CONST .)
    FOR             reduce using rule 44 (ret_op -> RETURN CONST .)
    CONST           reduce using rule 44 (ret_op -> RETURN CONST .)
    $end            reduce using rule 44 (ret_op -> RETURN CONST .)
    UNTIL           reduce using rule 44 (ret_op -> RETURN CONST .)
    ENDIF           reduce using rule 44 (ret_op -> RETURN CONST .)
    ELSE            reduce using rule 44 (ret_op -> RETURN CONST .)
    ENDWHILE        reduce using rule 44 (ret_op -> RETURN CONST .)
    ENDFUNCTION     reduce using rule 44 (ret_op -> RETURN CONST .)
    ENDFOR          reduce using rule 44 (ret_op -> RETURN CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 55

    (45) ret_op -> RETURN ar_op .

    ID              reduce using rule 45 (ret_op -> RETURN ar_op .)
    PRINT           reduce using rule 45 (ret_op -> RETURN ar_op .)
    READ            reduce using rule 45 (ret_op -> RETURN ar_op .)
    REPEAT          reduce using rule 45 (ret_op -> RETURN ar_op .)
    RETURN          reduce using rule 45 (ret_op -> RETURN ar_op .)
    IF              reduce using rule 45 (ret_op -> RETURN ar_op .)
    WHILE           reduce using rule 45 (ret_op -> RETURN ar_op .)
    FOR             reduce using rule 45 (ret_op -> RETURN ar_op .)
    CONST           reduce using rule 45 (ret_op -> RETURN ar_op .)
    $end            reduce using rule 45 (ret_op -> RETURN ar_op .)
    UNTIL           reduce using rule 45 (ret_op -> RETURN ar_op .)
    ENDIF           reduce using rule 45 (ret_op -> RETURN ar_op .)
    ELSE            reduce using rule 45 (ret_op -> RETURN ar_op .)
    ENDWHILE        reduce using rule 45 (ret_op -> RETURN ar_op .)
    ENDFUNCTION     reduce using rule 45 (ret_op -> RETURN ar_op .)
    ENDFOR          reduce using rule 45 (ret_op -> RETURN ar_op .)


state 56

    (46) ret_op -> RETURN func_call .

    ID              reduce using rule 46 (ret_op -> RETURN func_call .)
    PRINT           reduce using rule 46 (ret_op -> RETURN func_call .)
    READ            reduce using rule 46 (ret_op -> RETURN func_call .)
    REPEAT          reduce using rule 46 (ret_op -> RETURN func_call .)
    RETURN          reduce using rule 46 (ret_op -> RETURN func_call .)
    IF              reduce using rule 46 (ret_op -> RETURN func_call .)
    WHILE           reduce using rule 46 (ret_op -> RETURN func_call .)
    FOR             reduce using rule 46 (ret_op -> RETURN func_call .)
    CONST           reduce using rule 46 (ret_op -> RETURN func_call .)
    $end            reduce using rule 46 (ret_op -> RETURN func_call .)
    UNTIL           reduce using rule 46 (ret_op -> RETURN func_call .)
    ENDIF           reduce using rule 46 (ret_op -> RETURN func_call .)
    ELSE            reduce using rule 46 (ret_op -> RETURN func_call .)
    ENDWHILE        reduce using rule 46 (ret_op -> RETURN func_call .)
    ENDFUNCTION     reduce using rule 46 (ret_op -> RETURN func_call .)
    ENDFOR          reduce using rule 46 (ret_op -> RETURN func_call .)


state 57

    (114) if -> IF cond . ATUNCI l_op ENDIF
    (115) if -> IF cond . ATUNCI l_op ELSE l_op ENDIF

    ATUNCI          shift and go to state 107


state 58

    (57) cond -> TRUE .

    ATUNCI          reduce using rule 57 (cond -> TRUE .)
    EXECUTA         reduce using rule 57 (cond -> TRUE .)


state 59

    (58) cond -> FALSE .

    ATUNCI          reduce using rule 58 (cond -> FALSE .)
    EXECUTA         reduce using rule 58 (cond -> FALSE .)


state 60

    (59) cond -> cond_op .

    ATUNCI          reduce using rule 59 (cond -> cond_op .)
    EXECUTA         reduce using rule 59 (cond -> cond_op .)


state 61

    (60) cond_op -> ID . LOWER ID
    (61) cond_op -> ID . LOWER CONST
    (64) cond_op -> ID . GREATER ID
    (65) cond_op -> ID . GREATER CONST
    (68) cond_op -> ID . LEQUAL ID
    (69) cond_op -> ID . LEQUAL CONST
    (72) cond_op -> ID . GEQUAL ID
    (73) cond_op -> ID . GEQUAL CONST
    (76) cond_op -> ID . EQUAL ID
    (77) cond_op -> ID . EQUAL CONST
    (80) cond_op -> ID . NEQUAL ID
    (81) cond_op -> ID . NEQUAL CONST
    (96) cond_op -> ID . LOWER ar_op
    (97) cond_op -> ID . GREATER ar_op
    (98) cond_op -> ID . LEQUAL ar_op
    (99) cond_op -> ID . GEQUAL ar_op
    (100) cond_op -> ID . EQUAL ar_op
    (101) cond_op -> ID . NEQUAL ar_op
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    LOWER           shift and go to state 108
    GREATER         shift and go to state 109
    LEQUAL          shift and go to state 110
    GEQUAL          shift and go to state 111
    EQUAL           shift and go to state 112
    NEQUAL          shift and go to state 113
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 62

    (62) cond_op -> CONST . LOWER ID
    (63) cond_op -> CONST . LOWER CONST
    (66) cond_op -> CONST . GREATER ID
    (67) cond_op -> CONST . GREATER CONST
    (70) cond_op -> CONST . LEQUAL ID
    (71) cond_op -> CONST . LEQUAL CONST
    (74) cond_op -> CONST . GEQUAL ID
    (75) cond_op -> CONST . GEQUAL CONST
    (78) cond_op -> CONST . EQUAL ID
    (79) cond_op -> CONST . EQUAL CONST
    (82) cond_op -> CONST . NEQUAL ID
    (83) cond_op -> CONST . NEQUAL CONST
    (108) cond_op -> CONST . LOWER ar_op
    (109) cond_op -> CONST . GREATER ar_op
    (110) cond_op -> CONST . LEQUAL ar_op
    (111) cond_op -> CONST . GEQUAL ar_op
    (112) cond_op -> CONST . EQUAL ar_op
    (113) cond_op -> CONST . NEQUAL ar_op
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    LOWER           shift and go to state 114
    GREATER         shift and go to state 115
    LEQUAL          shift and go to state 116
    GEQUAL          shift and go to state 117
    EQUAL           shift and go to state 118
    NEQUAL          shift and go to state 119
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 63

    (84) cond_op -> ar_op . LOWER ar_op
    (85) cond_op -> ar_op . GREATER ar_op
    (86) cond_op -> ar_op . LEQUAL ar_op
    (87) cond_op -> ar_op . GEQUAL ar_op
    (88) cond_op -> ar_op . EQUAL ar_op
    (89) cond_op -> ar_op . NEQUAL ar_op
    (90) cond_op -> ar_op . LOWER ID
    (91) cond_op -> ar_op . GREATER ID
    (92) cond_op -> ar_op . LEQUAL ID
    (93) cond_op -> ar_op . GEQUAL ID
    (94) cond_op -> ar_op . EQUAL ID
    (95) cond_op -> ar_op . NEQUAL ID
    (102) cond_op -> ar_op . LOWER CONST
    (103) cond_op -> ar_op . GREATER CONST
    (104) cond_op -> ar_op . LEQUAL CONST
    (105) cond_op -> ar_op . GEQUAL CONST
    (106) cond_op -> ar_op . EQUAL CONST
    (107) cond_op -> ar_op . NEQUAL CONST

    LOWER           shift and go to state 120
    GREATER         shift and go to state 121
    LEQUAL          shift and go to state 122
    GEQUAL          shift and go to state 123
    EQUAL           shift and go to state 124
    NEQUAL          shift and go to state 125


state 64

    (116) while -> WHILE cond . EXECUTA l_op ENDWHILE

    EXECUTA         shift and go to state 126


state 65

    (117) for -> FOR ID . ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> FOR ID . ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> FOR ID . ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> FOR ID . ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> FOR ID . ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> FOR ID . ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> FOR ID . ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> FOR ID . ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR

    ASSIGN          shift and go to state 127


state 66

    (128) func -> FUNCTION ID LPAREN . l_param RPAREN l_op ENDFUNCTION
    (129) func -> FUNCTION ID LPAREN . RPAREN l_op ENDFUNCTION
    (132) l_param -> . ID
    (133) l_param -> . ID COMMA l_param

    RPAREN          shift and go to state 129
    ID              shift and go to state 105

    l_param                        shift and go to state 128

state 67

    (37) attr -> ID ASSIGN ID .
    (130) func_call -> ID . LPAREN l_a_param RPAREN
    (131) func_call -> ID . LPAREN RPAREN
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ID              reduce using rule 37 (attr -> ID ASSIGN ID .)
    PRINT           reduce using rule 37 (attr -> ID ASSIGN ID .)
    READ            reduce using rule 37 (attr -> ID ASSIGN ID .)
    REPEAT          reduce using rule 37 (attr -> ID ASSIGN ID .)
    RETURN          reduce using rule 37 (attr -> ID ASSIGN ID .)
    IF              reduce using rule 37 (attr -> ID ASSIGN ID .)
    WHILE           reduce using rule 37 (attr -> ID ASSIGN ID .)
    FOR             reduce using rule 37 (attr -> ID ASSIGN ID .)
    CONST           reduce using rule 37 (attr -> ID ASSIGN ID .)
    $end            reduce using rule 37 (attr -> ID ASSIGN ID .)
    UNTIL           reduce using rule 37 (attr -> ID ASSIGN ID .)
    ENDIF           reduce using rule 37 (attr -> ID ASSIGN ID .)
    ELSE            reduce using rule 37 (attr -> ID ASSIGN ID .)
    ENDWHILE        reduce using rule 37 (attr -> ID ASSIGN ID .)
    ENDFUNCTION     reduce using rule 37 (attr -> ID ASSIGN ID .)
    ENDFOR          reduce using rule 37 (attr -> ID ASSIGN ID .)
    LPAREN          shift and go to state 37
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 68

    (38) attr -> ID ASSIGN CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ID              reduce using rule 38 (attr -> ID ASSIGN CONST .)
    PRINT           reduce using rule 38 (attr -> ID ASSIGN CONST .)
    READ            reduce using rule 38 (attr -> ID ASSIGN CONST .)
    REPEAT          reduce using rule 38 (attr -> ID ASSIGN CONST .)
    RETURN          reduce using rule 38 (attr -> ID ASSIGN CONST .)
    IF              reduce using rule 38 (attr -> ID ASSIGN CONST .)
    WHILE           reduce using rule 38 (attr -> ID ASSIGN CONST .)
    FOR             reduce using rule 38 (attr -> ID ASSIGN CONST .)
    CONST           reduce using rule 38 (attr -> ID ASSIGN CONST .)
    $end            reduce using rule 38 (attr -> ID ASSIGN CONST .)
    UNTIL           reduce using rule 38 (attr -> ID ASSIGN CONST .)
    ENDIF           reduce using rule 38 (attr -> ID ASSIGN CONST .)
    ELSE            reduce using rule 38 (attr -> ID ASSIGN CONST .)
    ENDWHILE        reduce using rule 38 (attr -> ID ASSIGN CONST .)
    ENDFUNCTION     reduce using rule 38 (attr -> ID ASSIGN CONST .)
    ENDFOR          reduce using rule 38 (attr -> ID ASSIGN CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 69

    (39) attr -> ID ASSIGN ar_op .

    ID              reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    PRINT           reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    READ            reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    REPEAT          reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    RETURN          reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    IF              reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    WHILE           reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    FOR             reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    CONST           reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    $end            reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    UNTIL           reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    ENDIF           reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    ELSE            reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    ENDWHILE        reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    ENDFUNCTION     reduce using rule 39 (attr -> ID ASSIGN ar_op .)
    ENDFOR          reduce using rule 39 (attr -> ID ASSIGN ar_op .)


state 70

    (40) attr -> ID ASSIGN TRUE .

    ID              reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    PRINT           reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    READ            reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    REPEAT          reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    RETURN          reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    IF              reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    WHILE           reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    FOR             reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    CONST           reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    $end            reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    UNTIL           reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    ENDIF           reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    ELSE            reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    ENDWHILE        reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    ENDFUNCTION     reduce using rule 40 (attr -> ID ASSIGN TRUE .)
    ENDFOR          reduce using rule 40 (attr -> ID ASSIGN TRUE .)


state 71

    (41) attr -> ID ASSIGN FALSE .

    ID              reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    PRINT           reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    READ            reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    REPEAT          reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    RETURN          reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    IF              reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    WHILE           reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    FOR             reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    CONST           reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    $end            reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    UNTIL           reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    ENDIF           reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    ELSE            reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    ENDWHILE        reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    ENDFUNCTION     reduce using rule 41 (attr -> ID ASSIGN FALSE .)
    ENDFOR          reduce using rule 41 (attr -> ID ASSIGN FALSE .)


state 72

    (42) attr -> ID ASSIGN func_call .

    ID              reduce using rule 42 (attr -> ID ASSIGN func_call .)
    PRINT           reduce using rule 42 (attr -> ID ASSIGN func_call .)
    READ            reduce using rule 42 (attr -> ID ASSIGN func_call .)
    REPEAT          reduce using rule 42 (attr -> ID ASSIGN func_call .)
    RETURN          reduce using rule 42 (attr -> ID ASSIGN func_call .)
    IF              reduce using rule 42 (attr -> ID ASSIGN func_call .)
    WHILE           reduce using rule 42 (attr -> ID ASSIGN func_call .)
    FOR             reduce using rule 42 (attr -> ID ASSIGN func_call .)
    CONST           reduce using rule 42 (attr -> ID ASSIGN func_call .)
    $end            reduce using rule 42 (attr -> ID ASSIGN func_call .)
    UNTIL           reduce using rule 42 (attr -> ID ASSIGN func_call .)
    ENDIF           reduce using rule 42 (attr -> ID ASSIGN func_call .)
    ELSE            reduce using rule 42 (attr -> ID ASSIGN func_call .)
    ENDWHILE        reduce using rule 42 (attr -> ID ASSIGN func_call .)
    ENDFUNCTION     reduce using rule 42 (attr -> ID ASSIGN func_call .)
    ENDFOR          reduce using rule 42 (attr -> ID ASSIGN func_call .)


state 73

    (135) l_a_param -> ID .
    (130) func_call -> ID . LPAREN l_a_param RPAREN
    (131) func_call -> ID . LPAREN RPAREN
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    RPAREN          reduce using rule 135 (l_a_param -> ID .)
    COMMA           reduce using rule 135 (l_a_param -> ID .)
    LPAREN          shift and go to state 37
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 74

    (130) func_call -> ID LPAREN l_a_param . RPAREN
    (138) l_a_param -> l_a_param . COMMA CONST
    (139) l_a_param -> l_a_param . COMMA ID

    RPAREN          shift and go to state 130
    COMMA           shift and go to state 131


state 75

    (131) func_call -> ID LPAREN RPAREN .

    ID              reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    READ            reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    REPEAT          reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    IF              reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    FOR             reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    CONST           reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    $end            reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    UNTIL           reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    ENDIF           reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    ENDWHILE        reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    ENDFUNCTION     reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    ENDFOR          reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 131 (func_call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 131 (func_call -> ID LPAREN RPAREN .)


state 76

    (134) l_a_param -> CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    RPAREN          reduce using rule 134 (l_a_param -> CONST .)
    COMMA           reduce using rule 134 (l_a_param -> CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 77

    (136) l_a_param -> ar_op .

    RPAREN          reduce using rule 136 (l_a_param -> ar_op .)
    COMMA           reduce using rule 136 (l_a_param -> ar_op .)


state 78

    (137) l_a_param -> func_call .

    RPAREN          reduce using rule 137 (l_a_param -> func_call .)
    COMMA           reduce using rule 137 (l_a_param -> func_call .)


state 79

    (13) add -> ID PLUS ID .

    ID              reduce using rule 13 (add -> ID PLUS ID .)
    PRINT           reduce using rule 13 (add -> ID PLUS ID .)
    READ            reduce using rule 13 (add -> ID PLUS ID .)
    REPEAT          reduce using rule 13 (add -> ID PLUS ID .)
    RETURN          reduce using rule 13 (add -> ID PLUS ID .)
    IF              reduce using rule 13 (add -> ID PLUS ID .)
    WHILE           reduce using rule 13 (add -> ID PLUS ID .)
    FOR             reduce using rule 13 (add -> ID PLUS ID .)
    CONST           reduce using rule 13 (add -> ID PLUS ID .)
    $end            reduce using rule 13 (add -> ID PLUS ID .)
    UNTIL           reduce using rule 13 (add -> ID PLUS ID .)
    ENDIF           reduce using rule 13 (add -> ID PLUS ID .)
    ELSE            reduce using rule 13 (add -> ID PLUS ID .)
    ENDWHILE        reduce using rule 13 (add -> ID PLUS ID .)
    ENDFUNCTION     reduce using rule 13 (add -> ID PLUS ID .)
    ENDFOR          reduce using rule 13 (add -> ID PLUS ID .)
    LOWER           reduce using rule 13 (add -> ID PLUS ID .)
    GREATER         reduce using rule 13 (add -> ID PLUS ID .)
    LEQUAL          reduce using rule 13 (add -> ID PLUS ID .)
    GEQUAL          reduce using rule 13 (add -> ID PLUS ID .)
    EQUAL           reduce using rule 13 (add -> ID PLUS ID .)
    NEQUAL          reduce using rule 13 (add -> ID PLUS ID .)
    RPAREN          reduce using rule 13 (add -> ID PLUS ID .)
    COMMA           reduce using rule 13 (add -> ID PLUS ID .)
    ATUNCI          reduce using rule 13 (add -> ID PLUS ID .)
    EXECUTA         reduce using rule 13 (add -> ID PLUS ID .)


state 80

    (15) add -> ID PLUS CONST .

    ID              reduce using rule 15 (add -> ID PLUS CONST .)
    PRINT           reduce using rule 15 (add -> ID PLUS CONST .)
    READ            reduce using rule 15 (add -> ID PLUS CONST .)
    REPEAT          reduce using rule 15 (add -> ID PLUS CONST .)
    RETURN          reduce using rule 15 (add -> ID PLUS CONST .)
    IF              reduce using rule 15 (add -> ID PLUS CONST .)
    WHILE           reduce using rule 15 (add -> ID PLUS CONST .)
    FOR             reduce using rule 15 (add -> ID PLUS CONST .)
    CONST           reduce using rule 15 (add -> ID PLUS CONST .)
    $end            reduce using rule 15 (add -> ID PLUS CONST .)
    UNTIL           reduce using rule 15 (add -> ID PLUS CONST .)
    ENDIF           reduce using rule 15 (add -> ID PLUS CONST .)
    ELSE            reduce using rule 15 (add -> ID PLUS CONST .)
    ENDWHILE        reduce using rule 15 (add -> ID PLUS CONST .)
    ENDFUNCTION     reduce using rule 15 (add -> ID PLUS CONST .)
    ENDFOR          reduce using rule 15 (add -> ID PLUS CONST .)
    LOWER           reduce using rule 15 (add -> ID PLUS CONST .)
    GREATER         reduce using rule 15 (add -> ID PLUS CONST .)
    LEQUAL          reduce using rule 15 (add -> ID PLUS CONST .)
    GEQUAL          reduce using rule 15 (add -> ID PLUS CONST .)
    EQUAL           reduce using rule 15 (add -> ID PLUS CONST .)
    NEQUAL          reduce using rule 15 (add -> ID PLUS CONST .)
    RPAREN          reduce using rule 15 (add -> ID PLUS CONST .)
    COMMA           reduce using rule 15 (add -> ID PLUS CONST .)
    ATUNCI          reduce using rule 15 (add -> ID PLUS CONST .)
    EXECUTA         reduce using rule 15 (add -> ID PLUS CONST .)


state 81

    (21) mul -> ID TIMES ID .

    ID              reduce using rule 21 (mul -> ID TIMES ID .)
    PRINT           reduce using rule 21 (mul -> ID TIMES ID .)
    READ            reduce using rule 21 (mul -> ID TIMES ID .)
    REPEAT          reduce using rule 21 (mul -> ID TIMES ID .)
    RETURN          reduce using rule 21 (mul -> ID TIMES ID .)
    IF              reduce using rule 21 (mul -> ID TIMES ID .)
    WHILE           reduce using rule 21 (mul -> ID TIMES ID .)
    FOR             reduce using rule 21 (mul -> ID TIMES ID .)
    CONST           reduce using rule 21 (mul -> ID TIMES ID .)
    $end            reduce using rule 21 (mul -> ID TIMES ID .)
    UNTIL           reduce using rule 21 (mul -> ID TIMES ID .)
    ENDIF           reduce using rule 21 (mul -> ID TIMES ID .)
    ELSE            reduce using rule 21 (mul -> ID TIMES ID .)
    ENDWHILE        reduce using rule 21 (mul -> ID TIMES ID .)
    ENDFUNCTION     reduce using rule 21 (mul -> ID TIMES ID .)
    ENDFOR          reduce using rule 21 (mul -> ID TIMES ID .)
    LOWER           reduce using rule 21 (mul -> ID TIMES ID .)
    GREATER         reduce using rule 21 (mul -> ID TIMES ID .)
    LEQUAL          reduce using rule 21 (mul -> ID TIMES ID .)
    GEQUAL          reduce using rule 21 (mul -> ID TIMES ID .)
    EQUAL           reduce using rule 21 (mul -> ID TIMES ID .)
    NEQUAL          reduce using rule 21 (mul -> ID TIMES ID .)
    RPAREN          reduce using rule 21 (mul -> ID TIMES ID .)
    COMMA           reduce using rule 21 (mul -> ID TIMES ID .)
    ATUNCI          reduce using rule 21 (mul -> ID TIMES ID .)
    EXECUTA         reduce using rule 21 (mul -> ID TIMES ID .)


state 82

    (23) mul -> ID TIMES CONST .

    ID              reduce using rule 23 (mul -> ID TIMES CONST .)
    PRINT           reduce using rule 23 (mul -> ID TIMES CONST .)
    READ            reduce using rule 23 (mul -> ID TIMES CONST .)
    REPEAT          reduce using rule 23 (mul -> ID TIMES CONST .)
    RETURN          reduce using rule 23 (mul -> ID TIMES CONST .)
    IF              reduce using rule 23 (mul -> ID TIMES CONST .)
    WHILE           reduce using rule 23 (mul -> ID TIMES CONST .)
    FOR             reduce using rule 23 (mul -> ID TIMES CONST .)
    CONST           reduce using rule 23 (mul -> ID TIMES CONST .)
    $end            reduce using rule 23 (mul -> ID TIMES CONST .)
    UNTIL           reduce using rule 23 (mul -> ID TIMES CONST .)
    ENDIF           reduce using rule 23 (mul -> ID TIMES CONST .)
    ELSE            reduce using rule 23 (mul -> ID TIMES CONST .)
    ENDWHILE        reduce using rule 23 (mul -> ID TIMES CONST .)
    ENDFUNCTION     reduce using rule 23 (mul -> ID TIMES CONST .)
    ENDFOR          reduce using rule 23 (mul -> ID TIMES CONST .)
    LOWER           reduce using rule 23 (mul -> ID TIMES CONST .)
    GREATER         reduce using rule 23 (mul -> ID TIMES CONST .)
    LEQUAL          reduce using rule 23 (mul -> ID TIMES CONST .)
    GEQUAL          reduce using rule 23 (mul -> ID TIMES CONST .)
    EQUAL           reduce using rule 23 (mul -> ID TIMES CONST .)
    NEQUAL          reduce using rule 23 (mul -> ID TIMES CONST .)
    RPAREN          reduce using rule 23 (mul -> ID TIMES CONST .)
    COMMA           reduce using rule 23 (mul -> ID TIMES CONST .)
    ATUNCI          reduce using rule 23 (mul -> ID TIMES CONST .)
    EXECUTA         reduce using rule 23 (mul -> ID TIMES CONST .)


state 83

    (17) sub -> ID MINUS ID .

    ID              reduce using rule 17 (sub -> ID MINUS ID .)
    PRINT           reduce using rule 17 (sub -> ID MINUS ID .)
    READ            reduce using rule 17 (sub -> ID MINUS ID .)
    REPEAT          reduce using rule 17 (sub -> ID MINUS ID .)
    RETURN          reduce using rule 17 (sub -> ID MINUS ID .)
    IF              reduce using rule 17 (sub -> ID MINUS ID .)
    WHILE           reduce using rule 17 (sub -> ID MINUS ID .)
    FOR             reduce using rule 17 (sub -> ID MINUS ID .)
    CONST           reduce using rule 17 (sub -> ID MINUS ID .)
    $end            reduce using rule 17 (sub -> ID MINUS ID .)
    UNTIL           reduce using rule 17 (sub -> ID MINUS ID .)
    ENDIF           reduce using rule 17 (sub -> ID MINUS ID .)
    ELSE            reduce using rule 17 (sub -> ID MINUS ID .)
    ENDWHILE        reduce using rule 17 (sub -> ID MINUS ID .)
    ENDFUNCTION     reduce using rule 17 (sub -> ID MINUS ID .)
    ENDFOR          reduce using rule 17 (sub -> ID MINUS ID .)
    LOWER           reduce using rule 17 (sub -> ID MINUS ID .)
    GREATER         reduce using rule 17 (sub -> ID MINUS ID .)
    LEQUAL          reduce using rule 17 (sub -> ID MINUS ID .)
    GEQUAL          reduce using rule 17 (sub -> ID MINUS ID .)
    EQUAL           reduce using rule 17 (sub -> ID MINUS ID .)
    NEQUAL          reduce using rule 17 (sub -> ID MINUS ID .)
    RPAREN          reduce using rule 17 (sub -> ID MINUS ID .)
    COMMA           reduce using rule 17 (sub -> ID MINUS ID .)
    ATUNCI          reduce using rule 17 (sub -> ID MINUS ID .)
    EXECUTA         reduce using rule 17 (sub -> ID MINUS ID .)


state 84

    (19) sub -> ID MINUS CONST .

    ID              reduce using rule 19 (sub -> ID MINUS CONST .)
    PRINT           reduce using rule 19 (sub -> ID MINUS CONST .)
    READ            reduce using rule 19 (sub -> ID MINUS CONST .)
    REPEAT          reduce using rule 19 (sub -> ID MINUS CONST .)
    RETURN          reduce using rule 19 (sub -> ID MINUS CONST .)
    IF              reduce using rule 19 (sub -> ID MINUS CONST .)
    WHILE           reduce using rule 19 (sub -> ID MINUS CONST .)
    FOR             reduce using rule 19 (sub -> ID MINUS CONST .)
    CONST           reduce using rule 19 (sub -> ID MINUS CONST .)
    $end            reduce using rule 19 (sub -> ID MINUS CONST .)
    UNTIL           reduce using rule 19 (sub -> ID MINUS CONST .)
    ENDIF           reduce using rule 19 (sub -> ID MINUS CONST .)
    ELSE            reduce using rule 19 (sub -> ID MINUS CONST .)
    ENDWHILE        reduce using rule 19 (sub -> ID MINUS CONST .)
    ENDFUNCTION     reduce using rule 19 (sub -> ID MINUS CONST .)
    ENDFOR          reduce using rule 19 (sub -> ID MINUS CONST .)
    LOWER           reduce using rule 19 (sub -> ID MINUS CONST .)
    GREATER         reduce using rule 19 (sub -> ID MINUS CONST .)
    LEQUAL          reduce using rule 19 (sub -> ID MINUS CONST .)
    GEQUAL          reduce using rule 19 (sub -> ID MINUS CONST .)
    EQUAL           reduce using rule 19 (sub -> ID MINUS CONST .)
    NEQUAL          reduce using rule 19 (sub -> ID MINUS CONST .)
    RPAREN          reduce using rule 19 (sub -> ID MINUS CONST .)
    COMMA           reduce using rule 19 (sub -> ID MINUS CONST .)
    ATUNCI          reduce using rule 19 (sub -> ID MINUS CONST .)
    EXECUTA         reduce using rule 19 (sub -> ID MINUS CONST .)


state 85

    (25) div -> ID DIV ID .

    ID              reduce using rule 25 (div -> ID DIV ID .)
    PRINT           reduce using rule 25 (div -> ID DIV ID .)
    READ            reduce using rule 25 (div -> ID DIV ID .)
    REPEAT          reduce using rule 25 (div -> ID DIV ID .)
    RETURN          reduce using rule 25 (div -> ID DIV ID .)
    IF              reduce using rule 25 (div -> ID DIV ID .)
    WHILE           reduce using rule 25 (div -> ID DIV ID .)
    FOR             reduce using rule 25 (div -> ID DIV ID .)
    CONST           reduce using rule 25 (div -> ID DIV ID .)
    $end            reduce using rule 25 (div -> ID DIV ID .)
    UNTIL           reduce using rule 25 (div -> ID DIV ID .)
    ENDIF           reduce using rule 25 (div -> ID DIV ID .)
    ELSE            reduce using rule 25 (div -> ID DIV ID .)
    ENDWHILE        reduce using rule 25 (div -> ID DIV ID .)
    ENDFUNCTION     reduce using rule 25 (div -> ID DIV ID .)
    ENDFOR          reduce using rule 25 (div -> ID DIV ID .)
    LOWER           reduce using rule 25 (div -> ID DIV ID .)
    GREATER         reduce using rule 25 (div -> ID DIV ID .)
    LEQUAL          reduce using rule 25 (div -> ID DIV ID .)
    GEQUAL          reduce using rule 25 (div -> ID DIV ID .)
    EQUAL           reduce using rule 25 (div -> ID DIV ID .)
    NEQUAL          reduce using rule 25 (div -> ID DIV ID .)
    RPAREN          reduce using rule 25 (div -> ID DIV ID .)
    COMMA           reduce using rule 25 (div -> ID DIV ID .)
    ATUNCI          reduce using rule 25 (div -> ID DIV ID .)
    EXECUTA         reduce using rule 25 (div -> ID DIV ID .)


state 86

    (27) div -> ID DIV CONST .

    ID              reduce using rule 27 (div -> ID DIV CONST .)
    PRINT           reduce using rule 27 (div -> ID DIV CONST .)
    READ            reduce using rule 27 (div -> ID DIV CONST .)
    REPEAT          reduce using rule 27 (div -> ID DIV CONST .)
    RETURN          reduce using rule 27 (div -> ID DIV CONST .)
    IF              reduce using rule 27 (div -> ID DIV CONST .)
    WHILE           reduce using rule 27 (div -> ID DIV CONST .)
    FOR             reduce using rule 27 (div -> ID DIV CONST .)
    CONST           reduce using rule 27 (div -> ID DIV CONST .)
    $end            reduce using rule 27 (div -> ID DIV CONST .)
    UNTIL           reduce using rule 27 (div -> ID DIV CONST .)
    ENDIF           reduce using rule 27 (div -> ID DIV CONST .)
    ELSE            reduce using rule 27 (div -> ID DIV CONST .)
    ENDWHILE        reduce using rule 27 (div -> ID DIV CONST .)
    ENDFUNCTION     reduce using rule 27 (div -> ID DIV CONST .)
    ENDFOR          reduce using rule 27 (div -> ID DIV CONST .)
    LOWER           reduce using rule 27 (div -> ID DIV CONST .)
    GREATER         reduce using rule 27 (div -> ID DIV CONST .)
    LEQUAL          reduce using rule 27 (div -> ID DIV CONST .)
    GEQUAL          reduce using rule 27 (div -> ID DIV CONST .)
    EQUAL           reduce using rule 27 (div -> ID DIV CONST .)
    NEQUAL          reduce using rule 27 (div -> ID DIV CONST .)
    RPAREN          reduce using rule 27 (div -> ID DIV CONST .)
    COMMA           reduce using rule 27 (div -> ID DIV CONST .)
    ATUNCI          reduce using rule 27 (div -> ID DIV CONST .)
    EXECUTA         reduce using rule 27 (div -> ID DIV CONST .)


state 87

    (29) rdiv -> ID DIVIDE ID .

    ID              reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    PRINT           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    READ            reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    REPEAT          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    RETURN          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    IF              reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    WHILE           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    FOR             reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    CONST           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    $end            reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    UNTIL           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    ENDIF           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    ELSE            reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    ENDWHILE        reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    ENDFUNCTION     reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    ENDFOR          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    LOWER           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    GREATER         reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    LEQUAL          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    GEQUAL          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    EQUAL           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    NEQUAL          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    RPAREN          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    COMMA           reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    ATUNCI          reduce using rule 29 (rdiv -> ID DIVIDE ID .)
    EXECUTA         reduce using rule 29 (rdiv -> ID DIVIDE ID .)


state 88

    (31) rdiv -> ID DIVIDE CONST .

    ID              reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    PRINT           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    READ            reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    REPEAT          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    RETURN          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    IF              reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    WHILE           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    FOR             reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    CONST           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    $end            reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    UNTIL           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    ENDIF           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    ELSE            reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    ENDWHILE        reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    ENDFUNCTION     reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    ENDFOR          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    LOWER           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    GREATER         reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    LEQUAL          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    GEQUAL          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    EQUAL           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    NEQUAL          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    RPAREN          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    COMMA           reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    ATUNCI          reduce using rule 31 (rdiv -> ID DIVIDE CONST .)
    EXECUTA         reduce using rule 31 (rdiv -> ID DIVIDE CONST .)


state 89

    (33) mod -> ID MOD ID .

    ID              reduce using rule 33 (mod -> ID MOD ID .)
    PRINT           reduce using rule 33 (mod -> ID MOD ID .)
    READ            reduce using rule 33 (mod -> ID MOD ID .)
    REPEAT          reduce using rule 33 (mod -> ID MOD ID .)
    RETURN          reduce using rule 33 (mod -> ID MOD ID .)
    IF              reduce using rule 33 (mod -> ID MOD ID .)
    WHILE           reduce using rule 33 (mod -> ID MOD ID .)
    FOR             reduce using rule 33 (mod -> ID MOD ID .)
    CONST           reduce using rule 33 (mod -> ID MOD ID .)
    $end            reduce using rule 33 (mod -> ID MOD ID .)
    UNTIL           reduce using rule 33 (mod -> ID MOD ID .)
    ENDIF           reduce using rule 33 (mod -> ID MOD ID .)
    ELSE            reduce using rule 33 (mod -> ID MOD ID .)
    ENDWHILE        reduce using rule 33 (mod -> ID MOD ID .)
    ENDFUNCTION     reduce using rule 33 (mod -> ID MOD ID .)
    ENDFOR          reduce using rule 33 (mod -> ID MOD ID .)
    LOWER           reduce using rule 33 (mod -> ID MOD ID .)
    GREATER         reduce using rule 33 (mod -> ID MOD ID .)
    LEQUAL          reduce using rule 33 (mod -> ID MOD ID .)
    GEQUAL          reduce using rule 33 (mod -> ID MOD ID .)
    EQUAL           reduce using rule 33 (mod -> ID MOD ID .)
    NEQUAL          reduce using rule 33 (mod -> ID MOD ID .)
    RPAREN          reduce using rule 33 (mod -> ID MOD ID .)
    COMMA           reduce using rule 33 (mod -> ID MOD ID .)
    ATUNCI          reduce using rule 33 (mod -> ID MOD ID .)
    EXECUTA         reduce using rule 33 (mod -> ID MOD ID .)


state 90

    (35) mod -> ID MOD CONST .

    ID              reduce using rule 35 (mod -> ID MOD CONST .)
    PRINT           reduce using rule 35 (mod -> ID MOD CONST .)
    READ            reduce using rule 35 (mod -> ID MOD CONST .)
    REPEAT          reduce using rule 35 (mod -> ID MOD CONST .)
    RETURN          reduce using rule 35 (mod -> ID MOD CONST .)
    IF              reduce using rule 35 (mod -> ID MOD CONST .)
    WHILE           reduce using rule 35 (mod -> ID MOD CONST .)
    FOR             reduce using rule 35 (mod -> ID MOD CONST .)
    CONST           reduce using rule 35 (mod -> ID MOD CONST .)
    $end            reduce using rule 35 (mod -> ID MOD CONST .)
    UNTIL           reduce using rule 35 (mod -> ID MOD CONST .)
    ENDIF           reduce using rule 35 (mod -> ID MOD CONST .)
    ELSE            reduce using rule 35 (mod -> ID MOD CONST .)
    ENDWHILE        reduce using rule 35 (mod -> ID MOD CONST .)
    ENDFUNCTION     reduce using rule 35 (mod -> ID MOD CONST .)
    ENDFOR          reduce using rule 35 (mod -> ID MOD CONST .)
    LOWER           reduce using rule 35 (mod -> ID MOD CONST .)
    GREATER         reduce using rule 35 (mod -> ID MOD CONST .)
    LEQUAL          reduce using rule 35 (mod -> ID MOD CONST .)
    GEQUAL          reduce using rule 35 (mod -> ID MOD CONST .)
    EQUAL           reduce using rule 35 (mod -> ID MOD CONST .)
    NEQUAL          reduce using rule 35 (mod -> ID MOD CONST .)
    RPAREN          reduce using rule 35 (mod -> ID MOD CONST .)
    COMMA           reduce using rule 35 (mod -> ID MOD CONST .)
    ATUNCI          reduce using rule 35 (mod -> ID MOD CONST .)
    EXECUTA         reduce using rule 35 (mod -> ID MOD CONST .)


state 91

    (16) add -> CONST PLUS CONST .

    ID              reduce using rule 16 (add -> CONST PLUS CONST .)
    PRINT           reduce using rule 16 (add -> CONST PLUS CONST .)
    READ            reduce using rule 16 (add -> CONST PLUS CONST .)
    REPEAT          reduce using rule 16 (add -> CONST PLUS CONST .)
    RETURN          reduce using rule 16 (add -> CONST PLUS CONST .)
    IF              reduce using rule 16 (add -> CONST PLUS CONST .)
    WHILE           reduce using rule 16 (add -> CONST PLUS CONST .)
    FOR             reduce using rule 16 (add -> CONST PLUS CONST .)
    CONST           reduce using rule 16 (add -> CONST PLUS CONST .)
    $end            reduce using rule 16 (add -> CONST PLUS CONST .)
    UNTIL           reduce using rule 16 (add -> CONST PLUS CONST .)
    ENDIF           reduce using rule 16 (add -> CONST PLUS CONST .)
    ELSE            reduce using rule 16 (add -> CONST PLUS CONST .)
    ENDWHILE        reduce using rule 16 (add -> CONST PLUS CONST .)
    ENDFUNCTION     reduce using rule 16 (add -> CONST PLUS CONST .)
    ENDFOR          reduce using rule 16 (add -> CONST PLUS CONST .)
    LOWER           reduce using rule 16 (add -> CONST PLUS CONST .)
    GREATER         reduce using rule 16 (add -> CONST PLUS CONST .)
    LEQUAL          reduce using rule 16 (add -> CONST PLUS CONST .)
    GEQUAL          reduce using rule 16 (add -> CONST PLUS CONST .)
    EQUAL           reduce using rule 16 (add -> CONST PLUS CONST .)
    NEQUAL          reduce using rule 16 (add -> CONST PLUS CONST .)
    RPAREN          reduce using rule 16 (add -> CONST PLUS CONST .)
    COMMA           reduce using rule 16 (add -> CONST PLUS CONST .)
    ATUNCI          reduce using rule 16 (add -> CONST PLUS CONST .)
    EXECUTA         reduce using rule 16 (add -> CONST PLUS CONST .)


state 92

    (14) add -> CONST PLUS ID .

    ID              reduce using rule 14 (add -> CONST PLUS ID .)
    PRINT           reduce using rule 14 (add -> CONST PLUS ID .)
    READ            reduce using rule 14 (add -> CONST PLUS ID .)
    REPEAT          reduce using rule 14 (add -> CONST PLUS ID .)
    RETURN          reduce using rule 14 (add -> CONST PLUS ID .)
    IF              reduce using rule 14 (add -> CONST PLUS ID .)
    WHILE           reduce using rule 14 (add -> CONST PLUS ID .)
    FOR             reduce using rule 14 (add -> CONST PLUS ID .)
    CONST           reduce using rule 14 (add -> CONST PLUS ID .)
    $end            reduce using rule 14 (add -> CONST PLUS ID .)
    UNTIL           reduce using rule 14 (add -> CONST PLUS ID .)
    ENDIF           reduce using rule 14 (add -> CONST PLUS ID .)
    ELSE            reduce using rule 14 (add -> CONST PLUS ID .)
    ENDWHILE        reduce using rule 14 (add -> CONST PLUS ID .)
    ENDFUNCTION     reduce using rule 14 (add -> CONST PLUS ID .)
    ENDFOR          reduce using rule 14 (add -> CONST PLUS ID .)
    LOWER           reduce using rule 14 (add -> CONST PLUS ID .)
    GREATER         reduce using rule 14 (add -> CONST PLUS ID .)
    LEQUAL          reduce using rule 14 (add -> CONST PLUS ID .)
    GEQUAL          reduce using rule 14 (add -> CONST PLUS ID .)
    EQUAL           reduce using rule 14 (add -> CONST PLUS ID .)
    NEQUAL          reduce using rule 14 (add -> CONST PLUS ID .)
    RPAREN          reduce using rule 14 (add -> CONST PLUS ID .)
    COMMA           reduce using rule 14 (add -> CONST PLUS ID .)
    ATUNCI          reduce using rule 14 (add -> CONST PLUS ID .)
    EXECUTA         reduce using rule 14 (add -> CONST PLUS ID .)


state 93

    (24) mul -> CONST TIMES CONST .

    ID              reduce using rule 24 (mul -> CONST TIMES CONST .)
    PRINT           reduce using rule 24 (mul -> CONST TIMES CONST .)
    READ            reduce using rule 24 (mul -> CONST TIMES CONST .)
    REPEAT          reduce using rule 24 (mul -> CONST TIMES CONST .)
    RETURN          reduce using rule 24 (mul -> CONST TIMES CONST .)
    IF              reduce using rule 24 (mul -> CONST TIMES CONST .)
    WHILE           reduce using rule 24 (mul -> CONST TIMES CONST .)
    FOR             reduce using rule 24 (mul -> CONST TIMES CONST .)
    CONST           reduce using rule 24 (mul -> CONST TIMES CONST .)
    $end            reduce using rule 24 (mul -> CONST TIMES CONST .)
    UNTIL           reduce using rule 24 (mul -> CONST TIMES CONST .)
    ENDIF           reduce using rule 24 (mul -> CONST TIMES CONST .)
    ELSE            reduce using rule 24 (mul -> CONST TIMES CONST .)
    ENDWHILE        reduce using rule 24 (mul -> CONST TIMES CONST .)
    ENDFUNCTION     reduce using rule 24 (mul -> CONST TIMES CONST .)
    ENDFOR          reduce using rule 24 (mul -> CONST TIMES CONST .)
    LOWER           reduce using rule 24 (mul -> CONST TIMES CONST .)
    GREATER         reduce using rule 24 (mul -> CONST TIMES CONST .)
    LEQUAL          reduce using rule 24 (mul -> CONST TIMES CONST .)
    GEQUAL          reduce using rule 24 (mul -> CONST TIMES CONST .)
    EQUAL           reduce using rule 24 (mul -> CONST TIMES CONST .)
    NEQUAL          reduce using rule 24 (mul -> CONST TIMES CONST .)
    RPAREN          reduce using rule 24 (mul -> CONST TIMES CONST .)
    COMMA           reduce using rule 24 (mul -> CONST TIMES CONST .)
    ATUNCI          reduce using rule 24 (mul -> CONST TIMES CONST .)
    EXECUTA         reduce using rule 24 (mul -> CONST TIMES CONST .)


state 94

    (22) mul -> CONST TIMES ID .

    ID              reduce using rule 22 (mul -> CONST TIMES ID .)
    PRINT           reduce using rule 22 (mul -> CONST TIMES ID .)
    READ            reduce using rule 22 (mul -> CONST TIMES ID .)
    REPEAT          reduce using rule 22 (mul -> CONST TIMES ID .)
    RETURN          reduce using rule 22 (mul -> CONST TIMES ID .)
    IF              reduce using rule 22 (mul -> CONST TIMES ID .)
    WHILE           reduce using rule 22 (mul -> CONST TIMES ID .)
    FOR             reduce using rule 22 (mul -> CONST TIMES ID .)
    CONST           reduce using rule 22 (mul -> CONST TIMES ID .)
    $end            reduce using rule 22 (mul -> CONST TIMES ID .)
    UNTIL           reduce using rule 22 (mul -> CONST TIMES ID .)
    ENDIF           reduce using rule 22 (mul -> CONST TIMES ID .)
    ELSE            reduce using rule 22 (mul -> CONST TIMES ID .)
    ENDWHILE        reduce using rule 22 (mul -> CONST TIMES ID .)
    ENDFUNCTION     reduce using rule 22 (mul -> CONST TIMES ID .)
    ENDFOR          reduce using rule 22 (mul -> CONST TIMES ID .)
    LOWER           reduce using rule 22 (mul -> CONST TIMES ID .)
    GREATER         reduce using rule 22 (mul -> CONST TIMES ID .)
    LEQUAL          reduce using rule 22 (mul -> CONST TIMES ID .)
    GEQUAL          reduce using rule 22 (mul -> CONST TIMES ID .)
    EQUAL           reduce using rule 22 (mul -> CONST TIMES ID .)
    NEQUAL          reduce using rule 22 (mul -> CONST TIMES ID .)
    RPAREN          reduce using rule 22 (mul -> CONST TIMES ID .)
    COMMA           reduce using rule 22 (mul -> CONST TIMES ID .)
    ATUNCI          reduce using rule 22 (mul -> CONST TIMES ID .)
    EXECUTA         reduce using rule 22 (mul -> CONST TIMES ID .)


state 95

    (20) sub -> CONST MINUS CONST .

    ID              reduce using rule 20 (sub -> CONST MINUS CONST .)
    PRINT           reduce using rule 20 (sub -> CONST MINUS CONST .)
    READ            reduce using rule 20 (sub -> CONST MINUS CONST .)
    REPEAT          reduce using rule 20 (sub -> CONST MINUS CONST .)
    RETURN          reduce using rule 20 (sub -> CONST MINUS CONST .)
    IF              reduce using rule 20 (sub -> CONST MINUS CONST .)
    WHILE           reduce using rule 20 (sub -> CONST MINUS CONST .)
    FOR             reduce using rule 20 (sub -> CONST MINUS CONST .)
    CONST           reduce using rule 20 (sub -> CONST MINUS CONST .)
    $end            reduce using rule 20 (sub -> CONST MINUS CONST .)
    UNTIL           reduce using rule 20 (sub -> CONST MINUS CONST .)
    ENDIF           reduce using rule 20 (sub -> CONST MINUS CONST .)
    ELSE            reduce using rule 20 (sub -> CONST MINUS CONST .)
    ENDWHILE        reduce using rule 20 (sub -> CONST MINUS CONST .)
    ENDFUNCTION     reduce using rule 20 (sub -> CONST MINUS CONST .)
    ENDFOR          reduce using rule 20 (sub -> CONST MINUS CONST .)
    LOWER           reduce using rule 20 (sub -> CONST MINUS CONST .)
    GREATER         reduce using rule 20 (sub -> CONST MINUS CONST .)
    LEQUAL          reduce using rule 20 (sub -> CONST MINUS CONST .)
    GEQUAL          reduce using rule 20 (sub -> CONST MINUS CONST .)
    EQUAL           reduce using rule 20 (sub -> CONST MINUS CONST .)
    NEQUAL          reduce using rule 20 (sub -> CONST MINUS CONST .)
    RPAREN          reduce using rule 20 (sub -> CONST MINUS CONST .)
    COMMA           reduce using rule 20 (sub -> CONST MINUS CONST .)
    ATUNCI          reduce using rule 20 (sub -> CONST MINUS CONST .)
    EXECUTA         reduce using rule 20 (sub -> CONST MINUS CONST .)


state 96

    (18) sub -> CONST MINUS ID .

    ID              reduce using rule 18 (sub -> CONST MINUS ID .)
    PRINT           reduce using rule 18 (sub -> CONST MINUS ID .)
    READ            reduce using rule 18 (sub -> CONST MINUS ID .)
    REPEAT          reduce using rule 18 (sub -> CONST MINUS ID .)
    RETURN          reduce using rule 18 (sub -> CONST MINUS ID .)
    IF              reduce using rule 18 (sub -> CONST MINUS ID .)
    WHILE           reduce using rule 18 (sub -> CONST MINUS ID .)
    FOR             reduce using rule 18 (sub -> CONST MINUS ID .)
    CONST           reduce using rule 18 (sub -> CONST MINUS ID .)
    $end            reduce using rule 18 (sub -> CONST MINUS ID .)
    UNTIL           reduce using rule 18 (sub -> CONST MINUS ID .)
    ENDIF           reduce using rule 18 (sub -> CONST MINUS ID .)
    ELSE            reduce using rule 18 (sub -> CONST MINUS ID .)
    ENDWHILE        reduce using rule 18 (sub -> CONST MINUS ID .)
    ENDFUNCTION     reduce using rule 18 (sub -> CONST MINUS ID .)
    ENDFOR          reduce using rule 18 (sub -> CONST MINUS ID .)
    LOWER           reduce using rule 18 (sub -> CONST MINUS ID .)
    GREATER         reduce using rule 18 (sub -> CONST MINUS ID .)
    LEQUAL          reduce using rule 18 (sub -> CONST MINUS ID .)
    GEQUAL          reduce using rule 18 (sub -> CONST MINUS ID .)
    EQUAL           reduce using rule 18 (sub -> CONST MINUS ID .)
    NEQUAL          reduce using rule 18 (sub -> CONST MINUS ID .)
    RPAREN          reduce using rule 18 (sub -> CONST MINUS ID .)
    COMMA           reduce using rule 18 (sub -> CONST MINUS ID .)
    ATUNCI          reduce using rule 18 (sub -> CONST MINUS ID .)
    EXECUTA         reduce using rule 18 (sub -> CONST MINUS ID .)


state 97

    (28) div -> CONST DIV CONST .

    ID              reduce using rule 28 (div -> CONST DIV CONST .)
    PRINT           reduce using rule 28 (div -> CONST DIV CONST .)
    READ            reduce using rule 28 (div -> CONST DIV CONST .)
    REPEAT          reduce using rule 28 (div -> CONST DIV CONST .)
    RETURN          reduce using rule 28 (div -> CONST DIV CONST .)
    IF              reduce using rule 28 (div -> CONST DIV CONST .)
    WHILE           reduce using rule 28 (div -> CONST DIV CONST .)
    FOR             reduce using rule 28 (div -> CONST DIV CONST .)
    CONST           reduce using rule 28 (div -> CONST DIV CONST .)
    $end            reduce using rule 28 (div -> CONST DIV CONST .)
    UNTIL           reduce using rule 28 (div -> CONST DIV CONST .)
    ENDIF           reduce using rule 28 (div -> CONST DIV CONST .)
    ELSE            reduce using rule 28 (div -> CONST DIV CONST .)
    ENDWHILE        reduce using rule 28 (div -> CONST DIV CONST .)
    ENDFUNCTION     reduce using rule 28 (div -> CONST DIV CONST .)
    ENDFOR          reduce using rule 28 (div -> CONST DIV CONST .)
    LOWER           reduce using rule 28 (div -> CONST DIV CONST .)
    GREATER         reduce using rule 28 (div -> CONST DIV CONST .)
    LEQUAL          reduce using rule 28 (div -> CONST DIV CONST .)
    GEQUAL          reduce using rule 28 (div -> CONST DIV CONST .)
    EQUAL           reduce using rule 28 (div -> CONST DIV CONST .)
    NEQUAL          reduce using rule 28 (div -> CONST DIV CONST .)
    RPAREN          reduce using rule 28 (div -> CONST DIV CONST .)
    COMMA           reduce using rule 28 (div -> CONST DIV CONST .)
    ATUNCI          reduce using rule 28 (div -> CONST DIV CONST .)
    EXECUTA         reduce using rule 28 (div -> CONST DIV CONST .)


state 98

    (26) div -> CONST DIV ID .

    ID              reduce using rule 26 (div -> CONST DIV ID .)
    PRINT           reduce using rule 26 (div -> CONST DIV ID .)
    READ            reduce using rule 26 (div -> CONST DIV ID .)
    REPEAT          reduce using rule 26 (div -> CONST DIV ID .)
    RETURN          reduce using rule 26 (div -> CONST DIV ID .)
    IF              reduce using rule 26 (div -> CONST DIV ID .)
    WHILE           reduce using rule 26 (div -> CONST DIV ID .)
    FOR             reduce using rule 26 (div -> CONST DIV ID .)
    CONST           reduce using rule 26 (div -> CONST DIV ID .)
    $end            reduce using rule 26 (div -> CONST DIV ID .)
    UNTIL           reduce using rule 26 (div -> CONST DIV ID .)
    ENDIF           reduce using rule 26 (div -> CONST DIV ID .)
    ELSE            reduce using rule 26 (div -> CONST DIV ID .)
    ENDWHILE        reduce using rule 26 (div -> CONST DIV ID .)
    ENDFUNCTION     reduce using rule 26 (div -> CONST DIV ID .)
    ENDFOR          reduce using rule 26 (div -> CONST DIV ID .)
    LOWER           reduce using rule 26 (div -> CONST DIV ID .)
    GREATER         reduce using rule 26 (div -> CONST DIV ID .)
    LEQUAL          reduce using rule 26 (div -> CONST DIV ID .)
    GEQUAL          reduce using rule 26 (div -> CONST DIV ID .)
    EQUAL           reduce using rule 26 (div -> CONST DIV ID .)
    NEQUAL          reduce using rule 26 (div -> CONST DIV ID .)
    RPAREN          reduce using rule 26 (div -> CONST DIV ID .)
    COMMA           reduce using rule 26 (div -> CONST DIV ID .)
    ATUNCI          reduce using rule 26 (div -> CONST DIV ID .)
    EXECUTA         reduce using rule 26 (div -> CONST DIV ID .)


state 99

    (32) rdiv -> CONST DIVIDE CONST .

    ID              reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    PRINT           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    READ            reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    REPEAT          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    RETURN          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    IF              reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    WHILE           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    FOR             reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    CONST           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    $end            reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    UNTIL           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    ENDIF           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    ELSE            reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    ENDWHILE        reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    ENDFUNCTION     reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    ENDFOR          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    LOWER           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    GREATER         reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    LEQUAL          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    GEQUAL          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    EQUAL           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    NEQUAL          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    RPAREN          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    COMMA           reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    ATUNCI          reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)
    EXECUTA         reduce using rule 32 (rdiv -> CONST DIVIDE CONST .)


state 100

    (30) rdiv -> CONST DIVIDE ID .

    ID              reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    PRINT           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    READ            reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    REPEAT          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    RETURN          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    IF              reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    WHILE           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    FOR             reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    CONST           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    $end            reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    UNTIL           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    ENDIF           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    ELSE            reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    ENDWHILE        reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    ENDFUNCTION     reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    ENDFOR          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    LOWER           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    GREATER         reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    LEQUAL          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    GEQUAL          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    EQUAL           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    NEQUAL          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    RPAREN          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    COMMA           reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    ATUNCI          reduce using rule 30 (rdiv -> CONST DIVIDE ID .)
    EXECUTA         reduce using rule 30 (rdiv -> CONST DIVIDE ID .)


state 101

    (36) mod -> CONST MOD CONST .

    ID              reduce using rule 36 (mod -> CONST MOD CONST .)
    PRINT           reduce using rule 36 (mod -> CONST MOD CONST .)
    READ            reduce using rule 36 (mod -> CONST MOD CONST .)
    REPEAT          reduce using rule 36 (mod -> CONST MOD CONST .)
    RETURN          reduce using rule 36 (mod -> CONST MOD CONST .)
    IF              reduce using rule 36 (mod -> CONST MOD CONST .)
    WHILE           reduce using rule 36 (mod -> CONST MOD CONST .)
    FOR             reduce using rule 36 (mod -> CONST MOD CONST .)
    CONST           reduce using rule 36 (mod -> CONST MOD CONST .)
    $end            reduce using rule 36 (mod -> CONST MOD CONST .)
    UNTIL           reduce using rule 36 (mod -> CONST MOD CONST .)
    ENDIF           reduce using rule 36 (mod -> CONST MOD CONST .)
    ELSE            reduce using rule 36 (mod -> CONST MOD CONST .)
    ENDWHILE        reduce using rule 36 (mod -> CONST MOD CONST .)
    ENDFUNCTION     reduce using rule 36 (mod -> CONST MOD CONST .)
    ENDFOR          reduce using rule 36 (mod -> CONST MOD CONST .)
    LOWER           reduce using rule 36 (mod -> CONST MOD CONST .)
    GREATER         reduce using rule 36 (mod -> CONST MOD CONST .)
    LEQUAL          reduce using rule 36 (mod -> CONST MOD CONST .)
    GEQUAL          reduce using rule 36 (mod -> CONST MOD CONST .)
    EQUAL           reduce using rule 36 (mod -> CONST MOD CONST .)
    NEQUAL          reduce using rule 36 (mod -> CONST MOD CONST .)
    RPAREN          reduce using rule 36 (mod -> CONST MOD CONST .)
    COMMA           reduce using rule 36 (mod -> CONST MOD CONST .)
    ATUNCI          reduce using rule 36 (mod -> CONST MOD CONST .)
    EXECUTA         reduce using rule 36 (mod -> CONST MOD CONST .)


state 102

    (34) mod -> CONST MOD ID .

    ID              reduce using rule 34 (mod -> CONST MOD ID .)
    PRINT           reduce using rule 34 (mod -> CONST MOD ID .)
    READ            reduce using rule 34 (mod -> CONST MOD ID .)
    REPEAT          reduce using rule 34 (mod -> CONST MOD ID .)
    RETURN          reduce using rule 34 (mod -> CONST MOD ID .)
    IF              reduce using rule 34 (mod -> CONST MOD ID .)
    WHILE           reduce using rule 34 (mod -> CONST MOD ID .)
    FOR             reduce using rule 34 (mod -> CONST MOD ID .)
    CONST           reduce using rule 34 (mod -> CONST MOD ID .)
    $end            reduce using rule 34 (mod -> CONST MOD ID .)
    UNTIL           reduce using rule 34 (mod -> CONST MOD ID .)
    ENDIF           reduce using rule 34 (mod -> CONST MOD ID .)
    ELSE            reduce using rule 34 (mod -> CONST MOD ID .)
    ENDWHILE        reduce using rule 34 (mod -> CONST MOD ID .)
    ENDFUNCTION     reduce using rule 34 (mod -> CONST MOD ID .)
    ENDFOR          reduce using rule 34 (mod -> CONST MOD ID .)
    LOWER           reduce using rule 34 (mod -> CONST MOD ID .)
    GREATER         reduce using rule 34 (mod -> CONST MOD ID .)
    LEQUAL          reduce using rule 34 (mod -> CONST MOD ID .)
    GEQUAL          reduce using rule 34 (mod -> CONST MOD ID .)
    EQUAL           reduce using rule 34 (mod -> CONST MOD ID .)
    NEQUAL          reduce using rule 34 (mod -> CONST MOD ID .)
    RPAREN          reduce using rule 34 (mod -> CONST MOD ID .)
    COMMA           reduce using rule 34 (mod -> CONST MOD ID .)
    ATUNCI          reduce using rule 34 (mod -> CONST MOD ID .)
    EXECUTA         reduce using rule 34 (mod -> CONST MOD ID .)


state 103

    (127) write -> PRINT LPAREN l_a_param . RPAREN
    (138) l_a_param -> l_a_param . COMMA CONST
    (139) l_a_param -> l_a_param . COMMA ID

    RPAREN          shift and go to state 132
    COMMA           shift and go to state 131


state 104

    (126) read -> READ LPAREN l_param . RPAREN

    RPAREN          shift and go to state 133


state 105

    (132) l_param -> ID .
    (133) l_param -> ID . COMMA l_param

    RPAREN          reduce using rule 132 (l_param -> ID .)
    COMMA           shift and go to state 134


state 106

    (125) repeat -> REPEAT l_op UNTIL . cond_op
    (60) cond_op -> . ID LOWER ID
    (61) cond_op -> . ID LOWER CONST
    (62) cond_op -> . CONST LOWER ID
    (63) cond_op -> . CONST LOWER CONST
    (64) cond_op -> . ID GREATER ID
    (65) cond_op -> . ID GREATER CONST
    (66) cond_op -> . CONST GREATER ID
    (67) cond_op -> . CONST GREATER CONST
    (68) cond_op -> . ID LEQUAL ID
    (69) cond_op -> . ID LEQUAL CONST
    (70) cond_op -> . CONST LEQUAL ID
    (71) cond_op -> . CONST LEQUAL CONST
    (72) cond_op -> . ID GEQUAL ID
    (73) cond_op -> . ID GEQUAL CONST
    (74) cond_op -> . CONST GEQUAL ID
    (75) cond_op -> . CONST GEQUAL CONST
    (76) cond_op -> . ID EQUAL ID
    (77) cond_op -> . ID EQUAL CONST
    (78) cond_op -> . CONST EQUAL ID
    (79) cond_op -> . CONST EQUAL CONST
    (80) cond_op -> . ID NEQUAL ID
    (81) cond_op -> . ID NEQUAL CONST
    (82) cond_op -> . CONST NEQUAL ID
    (83) cond_op -> . CONST NEQUAL CONST
    (84) cond_op -> . ar_op LOWER ar_op
    (85) cond_op -> . ar_op GREATER ar_op
    (86) cond_op -> . ar_op LEQUAL ar_op
    (87) cond_op -> . ar_op GEQUAL ar_op
    (88) cond_op -> . ar_op EQUAL ar_op
    (89) cond_op -> . ar_op NEQUAL ar_op
    (90) cond_op -> . ar_op LOWER ID
    (91) cond_op -> . ar_op GREATER ID
    (92) cond_op -> . ar_op LEQUAL ID
    (93) cond_op -> . ar_op GEQUAL ID
    (94) cond_op -> . ar_op EQUAL ID
    (95) cond_op -> . ar_op NEQUAL ID
    (96) cond_op -> . ID LOWER ar_op
    (97) cond_op -> . ID GREATER ar_op
    (98) cond_op -> . ID LEQUAL ar_op
    (99) cond_op -> . ID GEQUAL ar_op
    (100) cond_op -> . ID EQUAL ar_op
    (101) cond_op -> . ID NEQUAL ar_op
    (102) cond_op -> . ar_op LOWER CONST
    (103) cond_op -> . ar_op GREATER CONST
    (104) cond_op -> . ar_op LEQUAL CONST
    (105) cond_op -> . ar_op GEQUAL CONST
    (106) cond_op -> . ar_op EQUAL CONST
    (107) cond_op -> . ar_op NEQUAL CONST
    (108) cond_op -> . CONST LOWER ar_op
    (109) cond_op -> . CONST GREATER ar_op
    (110) cond_op -> . CONST LEQUAL ar_op
    (111) cond_op -> . CONST GEQUAL ar_op
    (112) cond_op -> . CONST EQUAL ar_op
    (113) cond_op -> . CONST NEQUAL ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 61
    CONST           shift and go to state 62

    cond_op                        shift and go to state 135
    ar_op                          shift and go to state 63
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 107

    (114) if -> IF cond ATUNCI . l_op ENDIF
    (115) if -> IF cond ATUNCI . l_op ELSE l_op ENDIF
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 136
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 108

    (60) cond_op -> ID LOWER . ID
    (61) cond_op -> ID LOWER . CONST
    (96) cond_op -> ID LOWER . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 137
    CONST           shift and go to state 138

    ar_op                          shift and go to state 139
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 109

    (64) cond_op -> ID GREATER . ID
    (65) cond_op -> ID GREATER . CONST
    (97) cond_op -> ID GREATER . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 140
    CONST           shift and go to state 141

    ar_op                          shift and go to state 142
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 110

    (68) cond_op -> ID LEQUAL . ID
    (69) cond_op -> ID LEQUAL . CONST
    (98) cond_op -> ID LEQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 143
    CONST           shift and go to state 144

    ar_op                          shift and go to state 145
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 111

    (72) cond_op -> ID GEQUAL . ID
    (73) cond_op -> ID GEQUAL . CONST
    (99) cond_op -> ID GEQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 146
    CONST           shift and go to state 147

    ar_op                          shift and go to state 148
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 112

    (76) cond_op -> ID EQUAL . ID
    (77) cond_op -> ID EQUAL . CONST
    (100) cond_op -> ID EQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 149
    CONST           shift and go to state 150

    ar_op                          shift and go to state 151
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 113

    (80) cond_op -> ID NEQUAL . ID
    (81) cond_op -> ID NEQUAL . CONST
    (101) cond_op -> ID NEQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 152
    CONST           shift and go to state 153

    ar_op                          shift and go to state 154
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 114

    (62) cond_op -> CONST LOWER . ID
    (63) cond_op -> CONST LOWER . CONST
    (108) cond_op -> CONST LOWER . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 156
    CONST           shift and go to state 155

    ar_op                          shift and go to state 157
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 115

    (66) cond_op -> CONST GREATER . ID
    (67) cond_op -> CONST GREATER . CONST
    (109) cond_op -> CONST GREATER . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 159
    CONST           shift and go to state 158

    ar_op                          shift and go to state 160
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 116

    (70) cond_op -> CONST LEQUAL . ID
    (71) cond_op -> CONST LEQUAL . CONST
    (110) cond_op -> CONST LEQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 162
    CONST           shift and go to state 161

    ar_op                          shift and go to state 163
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 117

    (74) cond_op -> CONST GEQUAL . ID
    (75) cond_op -> CONST GEQUAL . CONST
    (111) cond_op -> CONST GEQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 165
    CONST           shift and go to state 164

    ar_op                          shift and go to state 166
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 118

    (78) cond_op -> CONST EQUAL . ID
    (79) cond_op -> CONST EQUAL . CONST
    (112) cond_op -> CONST EQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 168
    CONST           shift and go to state 167

    ar_op                          shift and go to state 169
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 119

    (82) cond_op -> CONST NEQUAL . ID
    (83) cond_op -> CONST NEQUAL . CONST
    (113) cond_op -> CONST NEQUAL . ar_op
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 171
    CONST           shift and go to state 170

    ar_op                          shift and go to state 172
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 120

    (84) cond_op -> ar_op LOWER . ar_op
    (90) cond_op -> ar_op LOWER . ID
    (102) cond_op -> ar_op LOWER . CONST
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 174
    CONST           shift and go to state 175

    ar_op                          shift and go to state 173
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 121

    (85) cond_op -> ar_op GREATER . ar_op
    (91) cond_op -> ar_op GREATER . ID
    (103) cond_op -> ar_op GREATER . CONST
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 177
    CONST           shift and go to state 178

    ar_op                          shift and go to state 176
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 122

    (86) cond_op -> ar_op LEQUAL . ar_op
    (92) cond_op -> ar_op LEQUAL . ID
    (104) cond_op -> ar_op LEQUAL . CONST
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 180
    CONST           shift and go to state 181

    ar_op                          shift and go to state 179
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 123

    (87) cond_op -> ar_op GEQUAL . ar_op
    (93) cond_op -> ar_op GEQUAL . ID
    (105) cond_op -> ar_op GEQUAL . CONST
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 183
    CONST           shift and go to state 184

    ar_op                          shift and go to state 182
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 124

    (88) cond_op -> ar_op EQUAL . ar_op
    (94) cond_op -> ar_op EQUAL . ID
    (106) cond_op -> ar_op EQUAL . CONST
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 186
    CONST           shift and go to state 187

    ar_op                          shift and go to state 185
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 125

    (89) cond_op -> ar_op NEQUAL . ar_op
    (95) cond_op -> ar_op NEQUAL . ID
    (107) cond_op -> ar_op NEQUAL . CONST
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 189
    CONST           shift and go to state 190

    ar_op                          shift and go to state 188
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 126

    (116) while -> WHILE cond EXECUTA . l_op ENDWHILE
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 191
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 127

    (117) for -> FOR ID ASSIGN . ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> FOR ID ASSIGN . CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> FOR ID ASSIGN . ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> FOR ID ASSIGN . CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> FOR ID ASSIGN . ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> FOR ID ASSIGN . CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> FOR ID ASSIGN . ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> FOR ID ASSIGN . CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR

    ID              shift and go to state 192
    CONST           shift and go to state 193


state 128

    (128) func -> FUNCTION ID LPAREN l_param . RPAREN l_op ENDFUNCTION

    RPAREN          shift and go to state 194


state 129

    (129) func -> FUNCTION ID LPAREN RPAREN . l_op ENDFUNCTION
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 195
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 130

    (130) func_call -> ID LPAREN l_a_param RPAREN .

    ID              reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    PRINT           reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    READ            reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    REPEAT          reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    RETURN          reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    IF              reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    WHILE           reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    FOR             reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    CONST           reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    $end            reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    UNTIL           reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    ENDIF           reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    ELSE            reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    ENDWHILE        reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    ENDFUNCTION     reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    ENDFOR          reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    RPAREN          reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)
    COMMA           reduce using rule 130 (func_call -> ID LPAREN l_a_param RPAREN .)


state 131

    (138) l_a_param -> l_a_param COMMA . CONST
    (139) l_a_param -> l_a_param COMMA . ID

    CONST           shift and go to state 196
    ID              shift and go to state 197


state 132

    (127) write -> PRINT LPAREN l_a_param RPAREN .

    ID              reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    PRINT           reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    READ            reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    REPEAT          reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    RETURN          reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    IF              reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    WHILE           reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    FOR             reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    CONST           reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    $end            reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    UNTIL           reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    ENDIF           reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    ELSE            reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    ENDWHILE        reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    ENDFUNCTION     reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)
    ENDFOR          reduce using rule 127 (write -> PRINT LPAREN l_a_param RPAREN .)


state 133

    (126) read -> READ LPAREN l_param RPAREN .

    ID              reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    PRINT           reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    READ            reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    REPEAT          reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    RETURN          reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    IF              reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    WHILE           reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    FOR             reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    CONST           reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    $end            reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    UNTIL           reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    ENDIF           reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    ELSE            reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    ENDWHILE        reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    ENDFUNCTION     reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)
    ENDFOR          reduce using rule 126 (read -> READ LPAREN l_param RPAREN .)


state 134

    (133) l_param -> ID COMMA . l_param
    (132) l_param -> . ID
    (133) l_param -> . ID COMMA l_param

    ID              shift and go to state 105

    l_param                        shift and go to state 198

state 135

    (125) repeat -> REPEAT l_op UNTIL cond_op .

    ID              reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    PRINT           reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    READ            reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    REPEAT          reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    RETURN          reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    IF              reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    WHILE           reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    FOR             reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    CONST           reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    $end            reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    UNTIL           reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    ENDIF           reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    ELSE            reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    ENDWHILE        reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    ENDFUNCTION     reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)
    ENDFOR          reduce using rule 125 (repeat -> REPEAT l_op UNTIL cond_op .)


state 136

    (114) if -> IF cond ATUNCI l_op . ENDIF
    (115) if -> IF cond ATUNCI l_op . ELSE l_op ENDIF

    ENDIF           shift and go to state 199
    ELSE            shift and go to state 200


state 137

    (60) cond_op -> ID LOWER ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 60 (cond_op -> ID LOWER ID .)
    EXECUTA         reduce using rule 60 (cond_op -> ID LOWER ID .)
    ID              reduce using rule 60 (cond_op -> ID LOWER ID .)
    PRINT           reduce using rule 60 (cond_op -> ID LOWER ID .)
    READ            reduce using rule 60 (cond_op -> ID LOWER ID .)
    REPEAT          reduce using rule 60 (cond_op -> ID LOWER ID .)
    RETURN          reduce using rule 60 (cond_op -> ID LOWER ID .)
    IF              reduce using rule 60 (cond_op -> ID LOWER ID .)
    WHILE           reduce using rule 60 (cond_op -> ID LOWER ID .)
    FOR             reduce using rule 60 (cond_op -> ID LOWER ID .)
    CONST           reduce using rule 60 (cond_op -> ID LOWER ID .)
    $end            reduce using rule 60 (cond_op -> ID LOWER ID .)
    UNTIL           reduce using rule 60 (cond_op -> ID LOWER ID .)
    ENDIF           reduce using rule 60 (cond_op -> ID LOWER ID .)
    ELSE            reduce using rule 60 (cond_op -> ID LOWER ID .)
    ENDWHILE        reduce using rule 60 (cond_op -> ID LOWER ID .)
    ENDFUNCTION     reduce using rule 60 (cond_op -> ID LOWER ID .)
    ENDFOR          reduce using rule 60 (cond_op -> ID LOWER ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 138

    (61) cond_op -> ID LOWER CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 61 (cond_op -> ID LOWER CONST .)
    EXECUTA         reduce using rule 61 (cond_op -> ID LOWER CONST .)
    ID              reduce using rule 61 (cond_op -> ID LOWER CONST .)
    PRINT           reduce using rule 61 (cond_op -> ID LOWER CONST .)
    READ            reduce using rule 61 (cond_op -> ID LOWER CONST .)
    REPEAT          reduce using rule 61 (cond_op -> ID LOWER CONST .)
    RETURN          reduce using rule 61 (cond_op -> ID LOWER CONST .)
    IF              reduce using rule 61 (cond_op -> ID LOWER CONST .)
    WHILE           reduce using rule 61 (cond_op -> ID LOWER CONST .)
    FOR             reduce using rule 61 (cond_op -> ID LOWER CONST .)
    CONST           reduce using rule 61 (cond_op -> ID LOWER CONST .)
    $end            reduce using rule 61 (cond_op -> ID LOWER CONST .)
    UNTIL           reduce using rule 61 (cond_op -> ID LOWER CONST .)
    ENDIF           reduce using rule 61 (cond_op -> ID LOWER CONST .)
    ELSE            reduce using rule 61 (cond_op -> ID LOWER CONST .)
    ENDWHILE        reduce using rule 61 (cond_op -> ID LOWER CONST .)
    ENDFUNCTION     reduce using rule 61 (cond_op -> ID LOWER CONST .)
    ENDFOR          reduce using rule 61 (cond_op -> ID LOWER CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 139

    (96) cond_op -> ID LOWER ar_op .

    ATUNCI          reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    EXECUTA         reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    ID              reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    PRINT           reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    READ            reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    REPEAT          reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    RETURN          reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    IF              reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    WHILE           reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    FOR             reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    CONST           reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    $end            reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    UNTIL           reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    ENDIF           reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    ELSE            reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    ENDWHILE        reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    ENDFUNCTION     reduce using rule 96 (cond_op -> ID LOWER ar_op .)
    ENDFOR          reduce using rule 96 (cond_op -> ID LOWER ar_op .)


state 140

    (64) cond_op -> ID GREATER ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 64 (cond_op -> ID GREATER ID .)
    EXECUTA         reduce using rule 64 (cond_op -> ID GREATER ID .)
    ID              reduce using rule 64 (cond_op -> ID GREATER ID .)
    PRINT           reduce using rule 64 (cond_op -> ID GREATER ID .)
    READ            reduce using rule 64 (cond_op -> ID GREATER ID .)
    REPEAT          reduce using rule 64 (cond_op -> ID GREATER ID .)
    RETURN          reduce using rule 64 (cond_op -> ID GREATER ID .)
    IF              reduce using rule 64 (cond_op -> ID GREATER ID .)
    WHILE           reduce using rule 64 (cond_op -> ID GREATER ID .)
    FOR             reduce using rule 64 (cond_op -> ID GREATER ID .)
    CONST           reduce using rule 64 (cond_op -> ID GREATER ID .)
    $end            reduce using rule 64 (cond_op -> ID GREATER ID .)
    UNTIL           reduce using rule 64 (cond_op -> ID GREATER ID .)
    ENDIF           reduce using rule 64 (cond_op -> ID GREATER ID .)
    ELSE            reduce using rule 64 (cond_op -> ID GREATER ID .)
    ENDWHILE        reduce using rule 64 (cond_op -> ID GREATER ID .)
    ENDFUNCTION     reduce using rule 64 (cond_op -> ID GREATER ID .)
    ENDFOR          reduce using rule 64 (cond_op -> ID GREATER ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 141

    (65) cond_op -> ID GREATER CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 65 (cond_op -> ID GREATER CONST .)
    EXECUTA         reduce using rule 65 (cond_op -> ID GREATER CONST .)
    ID              reduce using rule 65 (cond_op -> ID GREATER CONST .)
    PRINT           reduce using rule 65 (cond_op -> ID GREATER CONST .)
    READ            reduce using rule 65 (cond_op -> ID GREATER CONST .)
    REPEAT          reduce using rule 65 (cond_op -> ID GREATER CONST .)
    RETURN          reduce using rule 65 (cond_op -> ID GREATER CONST .)
    IF              reduce using rule 65 (cond_op -> ID GREATER CONST .)
    WHILE           reduce using rule 65 (cond_op -> ID GREATER CONST .)
    FOR             reduce using rule 65 (cond_op -> ID GREATER CONST .)
    CONST           reduce using rule 65 (cond_op -> ID GREATER CONST .)
    $end            reduce using rule 65 (cond_op -> ID GREATER CONST .)
    UNTIL           reduce using rule 65 (cond_op -> ID GREATER CONST .)
    ENDIF           reduce using rule 65 (cond_op -> ID GREATER CONST .)
    ELSE            reduce using rule 65 (cond_op -> ID GREATER CONST .)
    ENDWHILE        reduce using rule 65 (cond_op -> ID GREATER CONST .)
    ENDFUNCTION     reduce using rule 65 (cond_op -> ID GREATER CONST .)
    ENDFOR          reduce using rule 65 (cond_op -> ID GREATER CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 142

    (97) cond_op -> ID GREATER ar_op .

    ATUNCI          reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    EXECUTA         reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    ID              reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    PRINT           reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    READ            reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    REPEAT          reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    RETURN          reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    IF              reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    WHILE           reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    FOR             reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    CONST           reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    $end            reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    UNTIL           reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    ENDIF           reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    ELSE            reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    ENDWHILE        reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    ENDFUNCTION     reduce using rule 97 (cond_op -> ID GREATER ar_op .)
    ENDFOR          reduce using rule 97 (cond_op -> ID GREATER ar_op .)


state 143

    (68) cond_op -> ID LEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    EXECUTA         reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    ID              reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    PRINT           reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    READ            reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    REPEAT          reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    RETURN          reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    IF              reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    WHILE           reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    FOR             reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    CONST           reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    $end            reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    UNTIL           reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    ENDIF           reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    ELSE            reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    ENDWHILE        reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    ENDFUNCTION     reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    ENDFOR          reduce using rule 68 (cond_op -> ID LEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 144

    (69) cond_op -> ID LEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    EXECUTA         reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    ID              reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    PRINT           reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    READ            reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    REPEAT          reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    RETURN          reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    IF              reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    WHILE           reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    FOR             reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    CONST           reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    $end            reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    UNTIL           reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    ENDIF           reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    ELSE            reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    ENDWHILE        reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    ENDFUNCTION     reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    ENDFOR          reduce using rule 69 (cond_op -> ID LEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 145

    (98) cond_op -> ID LEQUAL ar_op .

    ATUNCI          reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    EXECUTA         reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    ID              reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    PRINT           reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    READ            reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    REPEAT          reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    RETURN          reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    IF              reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    WHILE           reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    FOR             reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    CONST           reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    $end            reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    UNTIL           reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    ENDIF           reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    ELSE            reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    ENDWHILE        reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)
    ENDFOR          reduce using rule 98 (cond_op -> ID LEQUAL ar_op .)


state 146

    (72) cond_op -> ID GEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    EXECUTA         reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    ID              reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    PRINT           reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    READ            reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    REPEAT          reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    RETURN          reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    IF              reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    WHILE           reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    FOR             reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    CONST           reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    $end            reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    UNTIL           reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    ENDIF           reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    ELSE            reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    ENDWHILE        reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    ENDFUNCTION     reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    ENDFOR          reduce using rule 72 (cond_op -> ID GEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 147

    (73) cond_op -> ID GEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    EXECUTA         reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    ID              reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    PRINT           reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    READ            reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    REPEAT          reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    RETURN          reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    IF              reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    WHILE           reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    FOR             reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    CONST           reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    $end            reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    UNTIL           reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    ENDIF           reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    ELSE            reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    ENDWHILE        reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    ENDFUNCTION     reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    ENDFOR          reduce using rule 73 (cond_op -> ID GEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 148

    (99) cond_op -> ID GEQUAL ar_op .

    ATUNCI          reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    EXECUTA         reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    ID              reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    PRINT           reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    READ            reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    REPEAT          reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    RETURN          reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    IF              reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    WHILE           reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    FOR             reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    CONST           reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    $end            reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    UNTIL           reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    ENDIF           reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    ELSE            reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    ENDWHILE        reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)
    ENDFOR          reduce using rule 99 (cond_op -> ID GEQUAL ar_op .)


state 149

    (76) cond_op -> ID EQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 76 (cond_op -> ID EQUAL ID .)
    EXECUTA         reduce using rule 76 (cond_op -> ID EQUAL ID .)
    ID              reduce using rule 76 (cond_op -> ID EQUAL ID .)
    PRINT           reduce using rule 76 (cond_op -> ID EQUAL ID .)
    READ            reduce using rule 76 (cond_op -> ID EQUAL ID .)
    REPEAT          reduce using rule 76 (cond_op -> ID EQUAL ID .)
    RETURN          reduce using rule 76 (cond_op -> ID EQUAL ID .)
    IF              reduce using rule 76 (cond_op -> ID EQUAL ID .)
    WHILE           reduce using rule 76 (cond_op -> ID EQUAL ID .)
    FOR             reduce using rule 76 (cond_op -> ID EQUAL ID .)
    CONST           reduce using rule 76 (cond_op -> ID EQUAL ID .)
    $end            reduce using rule 76 (cond_op -> ID EQUAL ID .)
    UNTIL           reduce using rule 76 (cond_op -> ID EQUAL ID .)
    ENDIF           reduce using rule 76 (cond_op -> ID EQUAL ID .)
    ELSE            reduce using rule 76 (cond_op -> ID EQUAL ID .)
    ENDWHILE        reduce using rule 76 (cond_op -> ID EQUAL ID .)
    ENDFUNCTION     reduce using rule 76 (cond_op -> ID EQUAL ID .)
    ENDFOR          reduce using rule 76 (cond_op -> ID EQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 150

    (77) cond_op -> ID EQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    EXECUTA         reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    ID              reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    PRINT           reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    READ            reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    REPEAT          reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    RETURN          reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    IF              reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    WHILE           reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    FOR             reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    CONST           reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    $end            reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    UNTIL           reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    ENDIF           reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    ELSE            reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    ENDWHILE        reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    ENDFUNCTION     reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    ENDFOR          reduce using rule 77 (cond_op -> ID EQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 151

    (100) cond_op -> ID EQUAL ar_op .

    ATUNCI          reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    EXECUTA         reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    ID              reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    PRINT           reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    READ            reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    REPEAT          reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    RETURN          reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    IF              reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    WHILE           reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    FOR             reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    CONST           reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    $end            reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    UNTIL           reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    ENDIF           reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    ELSE            reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    ENDWHILE        reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    ENDFUNCTION     reduce using rule 100 (cond_op -> ID EQUAL ar_op .)
    ENDFOR          reduce using rule 100 (cond_op -> ID EQUAL ar_op .)


state 152

    (80) cond_op -> ID NEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    EXECUTA         reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    ID              reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    PRINT           reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    READ            reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    REPEAT          reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    RETURN          reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    IF              reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    WHILE           reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    FOR             reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    CONST           reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    $end            reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    UNTIL           reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    ENDIF           reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    ELSE            reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    ENDWHILE        reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    ENDFUNCTION     reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    ENDFOR          reduce using rule 80 (cond_op -> ID NEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 153

    (81) cond_op -> ID NEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    EXECUTA         reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    ID              reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    PRINT           reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    READ            reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    REPEAT          reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    RETURN          reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    IF              reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    WHILE           reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    FOR             reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    CONST           reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    $end            reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    UNTIL           reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    ENDIF           reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    ELSE            reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    ENDWHILE        reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    ENDFUNCTION     reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    ENDFOR          reduce using rule 81 (cond_op -> ID NEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 154

    (101) cond_op -> ID NEQUAL ar_op .

    ATUNCI          reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    EXECUTA         reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    ID              reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    PRINT           reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    READ            reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    REPEAT          reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    RETURN          reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    IF              reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    WHILE           reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    FOR             reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    CONST           reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    $end            reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    UNTIL           reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    ENDIF           reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    ELSE            reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    ENDWHILE        reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)
    ENDFOR          reduce using rule 101 (cond_op -> ID NEQUAL ar_op .)


state 155

    (63) cond_op -> CONST LOWER CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    EXECUTA         reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    ID              reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    PRINT           reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    READ            reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    REPEAT          reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    RETURN          reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    IF              reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    WHILE           reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    FOR             reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    CONST           reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    $end            reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    UNTIL           reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    ENDIF           reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    ELSE            reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    ENDWHILE        reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    ENDFUNCTION     reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    ENDFOR          reduce using rule 63 (cond_op -> CONST LOWER CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 156

    (62) cond_op -> CONST LOWER ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 62 (cond_op -> CONST LOWER ID .)
    EXECUTA         reduce using rule 62 (cond_op -> CONST LOWER ID .)
    ID              reduce using rule 62 (cond_op -> CONST LOWER ID .)
    PRINT           reduce using rule 62 (cond_op -> CONST LOWER ID .)
    READ            reduce using rule 62 (cond_op -> CONST LOWER ID .)
    REPEAT          reduce using rule 62 (cond_op -> CONST LOWER ID .)
    RETURN          reduce using rule 62 (cond_op -> CONST LOWER ID .)
    IF              reduce using rule 62 (cond_op -> CONST LOWER ID .)
    WHILE           reduce using rule 62 (cond_op -> CONST LOWER ID .)
    FOR             reduce using rule 62 (cond_op -> CONST LOWER ID .)
    CONST           reduce using rule 62 (cond_op -> CONST LOWER ID .)
    $end            reduce using rule 62 (cond_op -> CONST LOWER ID .)
    UNTIL           reduce using rule 62 (cond_op -> CONST LOWER ID .)
    ENDIF           reduce using rule 62 (cond_op -> CONST LOWER ID .)
    ELSE            reduce using rule 62 (cond_op -> CONST LOWER ID .)
    ENDWHILE        reduce using rule 62 (cond_op -> CONST LOWER ID .)
    ENDFUNCTION     reduce using rule 62 (cond_op -> CONST LOWER ID .)
    ENDFOR          reduce using rule 62 (cond_op -> CONST LOWER ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 157

    (108) cond_op -> CONST LOWER ar_op .

    ATUNCI          reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    EXECUTA         reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    ID              reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    PRINT           reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    READ            reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    REPEAT          reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    RETURN          reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    IF              reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    WHILE           reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    FOR             reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    CONST           reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    $end            reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    UNTIL           reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    ENDIF           reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    ELSE            reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    ENDWHILE        reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    ENDFUNCTION     reduce using rule 108 (cond_op -> CONST LOWER ar_op .)
    ENDFOR          reduce using rule 108 (cond_op -> CONST LOWER ar_op .)


state 158

    (67) cond_op -> CONST GREATER CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    EXECUTA         reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    ID              reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    PRINT           reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    READ            reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    REPEAT          reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    RETURN          reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    IF              reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    WHILE           reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    FOR             reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    CONST           reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    $end            reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    UNTIL           reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    ENDIF           reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    ELSE            reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    ENDWHILE        reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    ENDFUNCTION     reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    ENDFOR          reduce using rule 67 (cond_op -> CONST GREATER CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 159

    (66) cond_op -> CONST GREATER ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 66 (cond_op -> CONST GREATER ID .)
    EXECUTA         reduce using rule 66 (cond_op -> CONST GREATER ID .)
    ID              reduce using rule 66 (cond_op -> CONST GREATER ID .)
    PRINT           reduce using rule 66 (cond_op -> CONST GREATER ID .)
    READ            reduce using rule 66 (cond_op -> CONST GREATER ID .)
    REPEAT          reduce using rule 66 (cond_op -> CONST GREATER ID .)
    RETURN          reduce using rule 66 (cond_op -> CONST GREATER ID .)
    IF              reduce using rule 66 (cond_op -> CONST GREATER ID .)
    WHILE           reduce using rule 66 (cond_op -> CONST GREATER ID .)
    FOR             reduce using rule 66 (cond_op -> CONST GREATER ID .)
    CONST           reduce using rule 66 (cond_op -> CONST GREATER ID .)
    $end            reduce using rule 66 (cond_op -> CONST GREATER ID .)
    UNTIL           reduce using rule 66 (cond_op -> CONST GREATER ID .)
    ENDIF           reduce using rule 66 (cond_op -> CONST GREATER ID .)
    ELSE            reduce using rule 66 (cond_op -> CONST GREATER ID .)
    ENDWHILE        reduce using rule 66 (cond_op -> CONST GREATER ID .)
    ENDFUNCTION     reduce using rule 66 (cond_op -> CONST GREATER ID .)
    ENDFOR          reduce using rule 66 (cond_op -> CONST GREATER ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 160

    (109) cond_op -> CONST GREATER ar_op .

    ATUNCI          reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    EXECUTA         reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    ID              reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    PRINT           reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    READ            reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    REPEAT          reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    RETURN          reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    IF              reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    WHILE           reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    FOR             reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    CONST           reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    $end            reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    UNTIL           reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    ENDIF           reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    ELSE            reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    ENDWHILE        reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    ENDFUNCTION     reduce using rule 109 (cond_op -> CONST GREATER ar_op .)
    ENDFOR          reduce using rule 109 (cond_op -> CONST GREATER ar_op .)


state 161

    (71) cond_op -> CONST LEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    EXECUTA         reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    ID              reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    PRINT           reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    READ            reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    REPEAT          reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    RETURN          reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    IF              reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    WHILE           reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    FOR             reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    CONST           reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    $end            reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    UNTIL           reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    ENDIF           reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    ELSE            reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    ENDWHILE        reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    ENDFUNCTION     reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    ENDFOR          reduce using rule 71 (cond_op -> CONST LEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 162

    (70) cond_op -> CONST LEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    EXECUTA         reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    ID              reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    PRINT           reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    READ            reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    REPEAT          reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    RETURN          reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    IF              reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    WHILE           reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    FOR             reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    CONST           reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    $end            reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    UNTIL           reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    ENDIF           reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    ELSE            reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    ENDWHILE        reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    ENDFUNCTION     reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    ENDFOR          reduce using rule 70 (cond_op -> CONST LEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 163

    (110) cond_op -> CONST LEQUAL ar_op .

    ATUNCI          reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    EXECUTA         reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    ID              reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    PRINT           reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    READ            reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    REPEAT          reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    RETURN          reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    IF              reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    WHILE           reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    FOR             reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    CONST           reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    $end            reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    UNTIL           reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    ENDIF           reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    ELSE            reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    ENDWHILE        reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)
    ENDFOR          reduce using rule 110 (cond_op -> CONST LEQUAL ar_op .)


state 164

    (75) cond_op -> CONST GEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    EXECUTA         reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    ID              reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    PRINT           reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    READ            reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    REPEAT          reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    RETURN          reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    IF              reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    WHILE           reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    FOR             reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    CONST           reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    $end            reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    UNTIL           reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    ENDIF           reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    ELSE            reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    ENDWHILE        reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    ENDFUNCTION     reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    ENDFOR          reduce using rule 75 (cond_op -> CONST GEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 165

    (74) cond_op -> CONST GEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    EXECUTA         reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    ID              reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    PRINT           reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    READ            reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    REPEAT          reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    RETURN          reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    IF              reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    WHILE           reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    FOR             reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    CONST           reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    $end            reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    UNTIL           reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    ENDIF           reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    ELSE            reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    ENDWHILE        reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    ENDFUNCTION     reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    ENDFOR          reduce using rule 74 (cond_op -> CONST GEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 166

    (111) cond_op -> CONST GEQUAL ar_op .

    ATUNCI          reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    EXECUTA         reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    ID              reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    PRINT           reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    READ            reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    REPEAT          reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    RETURN          reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    IF              reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    WHILE           reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    FOR             reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    CONST           reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    $end            reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    UNTIL           reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    ENDIF           reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    ELSE            reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    ENDWHILE        reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)
    ENDFOR          reduce using rule 111 (cond_op -> CONST GEQUAL ar_op .)


state 167

    (79) cond_op -> CONST EQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    EXECUTA         reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    ID              reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    PRINT           reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    READ            reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    REPEAT          reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    RETURN          reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    IF              reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    WHILE           reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    FOR             reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    CONST           reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    $end            reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    UNTIL           reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    ENDIF           reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    ELSE            reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    ENDWHILE        reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    ENDFUNCTION     reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    ENDFOR          reduce using rule 79 (cond_op -> CONST EQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 168

    (78) cond_op -> CONST EQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    EXECUTA         reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    ID              reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    PRINT           reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    READ            reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    REPEAT          reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    RETURN          reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    IF              reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    WHILE           reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    FOR             reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    CONST           reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    $end            reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    UNTIL           reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    ENDIF           reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    ELSE            reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    ENDWHILE        reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    ENDFUNCTION     reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    ENDFOR          reduce using rule 78 (cond_op -> CONST EQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 169

    (112) cond_op -> CONST EQUAL ar_op .

    ATUNCI          reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    EXECUTA         reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    ID              reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    PRINT           reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    READ            reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    REPEAT          reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    RETURN          reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    IF              reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    WHILE           reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    FOR             reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    CONST           reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    $end            reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    UNTIL           reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    ENDIF           reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    ELSE            reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    ENDWHILE        reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    ENDFUNCTION     reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)
    ENDFOR          reduce using rule 112 (cond_op -> CONST EQUAL ar_op .)


state 170

    (83) cond_op -> CONST NEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    EXECUTA         reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    ID              reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    PRINT           reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    READ            reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    REPEAT          reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    RETURN          reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    IF              reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    WHILE           reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    FOR             reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    CONST           reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    $end            reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    UNTIL           reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    ENDIF           reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    ELSE            reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    ENDWHILE        reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    ENDFUNCTION     reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    ENDFOR          reduce using rule 83 (cond_op -> CONST NEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 171

    (82) cond_op -> CONST NEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    EXECUTA         reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    ID              reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    PRINT           reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    READ            reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    REPEAT          reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    RETURN          reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    IF              reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    WHILE           reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    FOR             reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    CONST           reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    $end            reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    UNTIL           reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    ENDIF           reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    ELSE            reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    ENDWHILE        reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    ENDFUNCTION     reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    ENDFOR          reduce using rule 82 (cond_op -> CONST NEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 172

    (113) cond_op -> CONST NEQUAL ar_op .

    ATUNCI          reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    EXECUTA         reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    ID              reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    PRINT           reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    READ            reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    REPEAT          reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    RETURN          reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    IF              reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    WHILE           reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    FOR             reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    CONST           reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    $end            reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    UNTIL           reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    ENDIF           reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    ELSE            reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    ENDWHILE        reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)
    ENDFOR          reduce using rule 113 (cond_op -> CONST NEQUAL ar_op .)


state 173

    (84) cond_op -> ar_op LOWER ar_op .

    ATUNCI          reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    EXECUTA         reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    ID              reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    PRINT           reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    READ            reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    REPEAT          reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    RETURN          reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    IF              reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    WHILE           reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    FOR             reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    CONST           reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    $end            reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    UNTIL           reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    ENDIF           reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    ELSE            reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    ENDWHILE        reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    ENDFUNCTION     reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)
    ENDFOR          reduce using rule 84 (cond_op -> ar_op LOWER ar_op .)


state 174

    (90) cond_op -> ar_op LOWER ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    EXECUTA         reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    ID              reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    PRINT           reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    READ            reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    REPEAT          reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    RETURN          reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    IF              reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    WHILE           reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    FOR             reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    CONST           reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    $end            reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    UNTIL           reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    ENDIF           reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    ELSE            reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    ENDWHILE        reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    ENDFUNCTION     reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    ENDFOR          reduce using rule 90 (cond_op -> ar_op LOWER ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 175

    (102) cond_op -> ar_op LOWER CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    EXECUTA         reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    ID              reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    PRINT           reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    READ            reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    REPEAT          reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    RETURN          reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    IF              reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    WHILE           reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    FOR             reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    CONST           reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    $end            reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    UNTIL           reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    ENDIF           reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    ELSE            reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    ENDWHILE        reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    ENDFUNCTION     reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    ENDFOR          reduce using rule 102 (cond_op -> ar_op LOWER CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 176

    (85) cond_op -> ar_op GREATER ar_op .

    ATUNCI          reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    EXECUTA         reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    ID              reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    PRINT           reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    READ            reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    REPEAT          reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    RETURN          reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    IF              reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    WHILE           reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    FOR             reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    CONST           reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    $end            reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    UNTIL           reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    ENDIF           reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    ELSE            reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    ENDWHILE        reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    ENDFUNCTION     reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)
    ENDFOR          reduce using rule 85 (cond_op -> ar_op GREATER ar_op .)


state 177

    (91) cond_op -> ar_op GREATER ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    EXECUTA         reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    ID              reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    PRINT           reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    READ            reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    REPEAT          reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    RETURN          reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    IF              reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    WHILE           reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    FOR             reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    CONST           reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    $end            reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    UNTIL           reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    ENDIF           reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    ELSE            reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    ENDWHILE        reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    ENDFUNCTION     reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    ENDFOR          reduce using rule 91 (cond_op -> ar_op GREATER ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 178

    (103) cond_op -> ar_op GREATER CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    EXECUTA         reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    ID              reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    PRINT           reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    READ            reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    REPEAT          reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    RETURN          reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    IF              reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    WHILE           reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    FOR             reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    CONST           reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    $end            reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    UNTIL           reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    ENDIF           reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    ELSE            reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    ENDWHILE        reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    ENDFUNCTION     reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    ENDFOR          reduce using rule 103 (cond_op -> ar_op GREATER CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 179

    (86) cond_op -> ar_op LEQUAL ar_op .

    ATUNCI          reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    EXECUTA         reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    ID              reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    PRINT           reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    READ            reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    REPEAT          reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    RETURN          reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    IF              reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    WHILE           reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    FOR             reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    CONST           reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    $end            reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    UNTIL           reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    ENDIF           reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    ELSE            reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    ENDWHILE        reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)
    ENDFOR          reduce using rule 86 (cond_op -> ar_op LEQUAL ar_op .)


state 180

    (92) cond_op -> ar_op LEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    EXECUTA         reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    ID              reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    PRINT           reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    READ            reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    REPEAT          reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    RETURN          reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    IF              reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    WHILE           reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    FOR             reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    CONST           reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    $end            reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    UNTIL           reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    ENDIF           reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    ELSE            reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    ENDWHILE        reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    ENDFUNCTION     reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    ENDFOR          reduce using rule 92 (cond_op -> ar_op LEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 181

    (104) cond_op -> ar_op LEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    EXECUTA         reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    ID              reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    PRINT           reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    READ            reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    REPEAT          reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    RETURN          reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    IF              reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    WHILE           reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    FOR             reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    CONST           reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    $end            reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    UNTIL           reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    ENDIF           reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    ELSE            reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    ENDWHILE        reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    ENDFUNCTION     reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    ENDFOR          reduce using rule 104 (cond_op -> ar_op LEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 182

    (87) cond_op -> ar_op GEQUAL ar_op .

    ATUNCI          reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    EXECUTA         reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    ID              reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    PRINT           reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    READ            reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    REPEAT          reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    RETURN          reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    IF              reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    WHILE           reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    FOR             reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    CONST           reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    $end            reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    UNTIL           reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    ENDIF           reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    ELSE            reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    ENDWHILE        reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)
    ENDFOR          reduce using rule 87 (cond_op -> ar_op GEQUAL ar_op .)


state 183

    (93) cond_op -> ar_op GEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    EXECUTA         reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    ID              reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    PRINT           reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    READ            reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    REPEAT          reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    RETURN          reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    IF              reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    WHILE           reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    FOR             reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    CONST           reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    $end            reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    UNTIL           reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    ENDIF           reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    ELSE            reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    ENDWHILE        reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    ENDFUNCTION     reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    ENDFOR          reduce using rule 93 (cond_op -> ar_op GEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 184

    (105) cond_op -> ar_op GEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    EXECUTA         reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    ID              reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    PRINT           reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    READ            reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    REPEAT          reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    RETURN          reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    IF              reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    WHILE           reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    FOR             reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    CONST           reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    $end            reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    UNTIL           reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    ENDIF           reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    ELSE            reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    ENDWHILE        reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    ENDFUNCTION     reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    ENDFOR          reduce using rule 105 (cond_op -> ar_op GEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 185

    (88) cond_op -> ar_op EQUAL ar_op .

    ATUNCI          reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    EXECUTA         reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    ID              reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    PRINT           reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    READ            reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    REPEAT          reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    RETURN          reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    IF              reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    WHILE           reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    FOR             reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    CONST           reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    $end            reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    UNTIL           reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    ENDIF           reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    ELSE            reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    ENDWHILE        reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    ENDFUNCTION     reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)
    ENDFOR          reduce using rule 88 (cond_op -> ar_op EQUAL ar_op .)


state 186

    (94) cond_op -> ar_op EQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    EXECUTA         reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    ID              reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    PRINT           reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    READ            reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    REPEAT          reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    RETURN          reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    IF              reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    WHILE           reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    FOR             reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    CONST           reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    $end            reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    UNTIL           reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    ENDIF           reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    ELSE            reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    ENDWHILE        reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    ENDFUNCTION     reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    ENDFOR          reduce using rule 94 (cond_op -> ar_op EQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 187

    (106) cond_op -> ar_op EQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    EXECUTA         reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    ID              reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    PRINT           reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    READ            reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    REPEAT          reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    RETURN          reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    IF              reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    WHILE           reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    FOR             reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    CONST           reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    $end            reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    UNTIL           reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    ENDIF           reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    ELSE            reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    ENDWHILE        reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    ENDFUNCTION     reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    ENDFOR          reduce using rule 106 (cond_op -> ar_op EQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 188

    (89) cond_op -> ar_op NEQUAL ar_op .

    ATUNCI          reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    EXECUTA         reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    ID              reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    PRINT           reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    READ            reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    REPEAT          reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    RETURN          reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    IF              reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    WHILE           reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    FOR             reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    CONST           reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    $end            reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    UNTIL           reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    ENDIF           reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    ELSE            reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    ENDWHILE        reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    ENDFUNCTION     reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)
    ENDFOR          reduce using rule 89 (cond_op -> ar_op NEQUAL ar_op .)


state 189

    (95) cond_op -> ar_op NEQUAL ID .
    (13) add -> ID . PLUS ID
    (15) add -> ID . PLUS CONST
    (21) mul -> ID . TIMES ID
    (23) mul -> ID . TIMES CONST
    (17) sub -> ID . MINUS ID
    (19) sub -> ID . MINUS CONST
    (25) div -> ID . DIV ID
    (27) div -> ID . DIV CONST
    (29) rdiv -> ID . DIVIDE ID
    (31) rdiv -> ID . DIVIDE CONST
    (33) mod -> ID . MOD ID
    (35) mod -> ID . MOD CONST

    ATUNCI          reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    EXECUTA         reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    ID              reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    PRINT           reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    READ            reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    REPEAT          reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    RETURN          reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    IF              reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    WHILE           reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    FOR             reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    CONST           reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    $end            reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    UNTIL           reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    ENDIF           reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    ELSE            reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    ENDWHILE        reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    ENDFUNCTION     reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    ENDFOR          reduce using rule 95 (cond_op -> ar_op NEQUAL ID .)
    PLUS            shift and go to state 38
    TIMES           shift and go to state 39
    MINUS           shift and go to state 40
    DIV             shift and go to state 41
    DIVIDE          shift and go to state 42
    MOD             shift and go to state 43


state 190

    (107) cond_op -> ar_op NEQUAL CONST .
    (14) add -> CONST . PLUS ID
    (16) add -> CONST . PLUS CONST
    (22) mul -> CONST . TIMES ID
    (24) mul -> CONST . TIMES CONST
    (18) sub -> CONST . MINUS ID
    (20) sub -> CONST . MINUS CONST
    (26) div -> CONST . DIV ID
    (28) div -> CONST . DIV CONST
    (30) rdiv -> CONST . DIVIDE ID
    (32) rdiv -> CONST . DIVIDE CONST
    (34) mod -> CONST . MOD ID
    (36) mod -> CONST . MOD CONST

    ATUNCI          reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    EXECUTA         reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    ID              reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    PRINT           reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    READ            reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    REPEAT          reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    RETURN          reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    IF              reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    WHILE           reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    FOR             reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    CONST           reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    $end            reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    UNTIL           reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    ENDIF           reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    ELSE            reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    ENDWHILE        reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    ENDFUNCTION     reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    ENDFOR          reduce using rule 107 (cond_op -> ar_op NEQUAL CONST .)
    PLUS            shift and go to state 44
    TIMES           shift and go to state 45
    MINUS           shift and go to state 46
    DIV             shift and go to state 47
    DIVIDE          shift and go to state 48
    MOD             shift and go to state 49


state 191

    (116) while -> WHILE cond EXECUTA l_op . ENDWHILE

    ENDWHILE        shift and go to state 201


state 192

    (117) for -> FOR ID ASSIGN ID . COMMA ID EXECUTA l_op ENDFOR
    (119) for -> FOR ID ASSIGN ID . COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> FOR ID ASSIGN ID . COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> FOR ID ASSIGN ID . COMMA CONST COMMA CONST EXECUTA l_op ENDFOR

    COMMA           shift and go to state 202


state 193

    (118) for -> FOR ID ASSIGN CONST . COMMA ID EXECUTA l_op ENDFOR
    (120) for -> FOR ID ASSIGN CONST . COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> FOR ID ASSIGN CONST . COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> FOR ID ASSIGN CONST . COMMA CONST COMMA CONST EXECUTA l_op ENDFOR

    COMMA           shift and go to state 203


state 194

    (128) func -> FUNCTION ID LPAREN l_param RPAREN . l_op ENDFUNCTION
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 204
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 195

    (129) func -> FUNCTION ID LPAREN RPAREN l_op . ENDFUNCTION

    ENDFUNCTION     shift and go to state 205


state 196

    (138) l_a_param -> l_a_param COMMA CONST .

    RPAREN          reduce using rule 138 (l_a_param -> l_a_param COMMA CONST .)
    COMMA           reduce using rule 138 (l_a_param -> l_a_param COMMA CONST .)


state 197

    (139) l_a_param -> l_a_param COMMA ID .

    RPAREN          reduce using rule 139 (l_a_param -> l_a_param COMMA ID .)
    COMMA           reduce using rule 139 (l_a_param -> l_a_param COMMA ID .)


state 198

    (133) l_param -> ID COMMA l_param .

    RPAREN          reduce using rule 133 (l_param -> ID COMMA l_param .)


state 199

    (114) if -> IF cond ATUNCI l_op ENDIF .

    ID              reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    PRINT           reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    READ            reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    REPEAT          reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    RETURN          reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    IF              reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    WHILE           reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    FOR             reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    CONST           reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    $end            reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    UNTIL           reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    ENDIF           reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    ELSE            reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    ENDWHILE        reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    ENDFUNCTION     reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)
    ENDFOR          reduce using rule 114 (if -> IF cond ATUNCI l_op ENDIF .)


state 200

    (115) if -> IF cond ATUNCI l_op ELSE . l_op ENDIF
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 206
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 201

    (116) while -> WHILE cond EXECUTA l_op ENDWHILE .

    ID              reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    PRINT           reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    READ            reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    REPEAT          reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    RETURN          reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    IF              reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    WHILE           reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    FOR             reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    CONST           reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    $end            reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    UNTIL           reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    ENDIF           reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    ELSE            reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    ENDWHILE        reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    ENDFUNCTION     reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)
    ENDFOR          reduce using rule 116 (while -> WHILE cond EXECUTA l_op ENDWHILE .)


state 202

    (117) for -> FOR ID ASSIGN ID COMMA . ID EXECUTA l_op ENDFOR
    (119) for -> FOR ID ASSIGN ID COMMA . CONST EXECUTA l_op ENDFOR
    (121) for -> FOR ID ASSIGN ID COMMA . ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> FOR ID ASSIGN ID COMMA . CONST COMMA CONST EXECUTA l_op ENDFOR

    ID              shift and go to state 207
    CONST           shift and go to state 208


state 203

    (118) for -> FOR ID ASSIGN CONST COMMA . ID EXECUTA l_op ENDFOR
    (120) for -> FOR ID ASSIGN CONST COMMA . CONST EXECUTA l_op ENDFOR
    (122) for -> FOR ID ASSIGN CONST COMMA . ID COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> FOR ID ASSIGN CONST COMMA . CONST COMMA CONST EXECUTA l_op ENDFOR

    ID              shift and go to state 209
    CONST           shift and go to state 210


state 204

    (128) func -> FUNCTION ID LPAREN l_param RPAREN l_op . ENDFUNCTION

    ENDFUNCTION     shift and go to state 211


state 205

    (129) func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .

    FUNCTION        reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    ID              reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    PRINT           reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    READ            reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    REPEAT          reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    RETURN          reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    IF              reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    WHILE           reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    FOR             reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)
    CONST           reduce using rule 129 (func -> FUNCTION ID LPAREN RPAREN l_op ENDFUNCTION .)


state 206

    (115) if -> IF cond ATUNCI l_op ELSE l_op . ENDIF

    ENDIF           shift and go to state 212


state 207

    (117) for -> FOR ID ASSIGN ID COMMA ID . EXECUTA l_op ENDFOR
    (121) for -> FOR ID ASSIGN ID COMMA ID . COMMA CONST EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 214
    COMMA           shift and go to state 213


state 208

    (119) for -> FOR ID ASSIGN ID COMMA CONST . EXECUTA l_op ENDFOR
    (123) for -> FOR ID ASSIGN ID COMMA CONST . COMMA CONST EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 216
    COMMA           shift and go to state 215


state 209

    (118) for -> FOR ID ASSIGN CONST COMMA ID . EXECUTA l_op ENDFOR
    (122) for -> FOR ID ASSIGN CONST COMMA ID . COMMA CONST EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 218
    COMMA           shift and go to state 217


state 210

    (120) for -> FOR ID ASSIGN CONST COMMA CONST . EXECUTA l_op ENDFOR
    (124) for -> FOR ID ASSIGN CONST COMMA CONST . COMMA CONST EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 220
    COMMA           shift and go to state 219


state 211

    (128) func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .

    FUNCTION        reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    ID              reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    PRINT           reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    READ            reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    REPEAT          reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    RETURN          reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    IF              reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    WHILE           reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    FOR             reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)
    CONST           reduce using rule 128 (func -> FUNCTION ID LPAREN l_param RPAREN l_op ENDFUNCTION .)


state 212

    (115) if -> IF cond ATUNCI l_op ELSE l_op ENDIF .

    ID              reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    PRINT           reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    READ            reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    REPEAT          reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    RETURN          reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    IF              reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    WHILE           reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    FOR             reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    CONST           reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    $end            reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    UNTIL           reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    ENDIF           reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    ELSE            reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    ENDWHILE        reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    ENDFUNCTION     reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)
    ENDFOR          reduce using rule 115 (if -> IF cond ATUNCI l_op ELSE l_op ENDIF .)


state 213

    (121) for -> FOR ID ASSIGN ID COMMA ID COMMA . CONST EXECUTA l_op ENDFOR

    CONST           shift and go to state 221


state 214

    (117) for -> FOR ID ASSIGN ID COMMA ID EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 222
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 215

    (123) for -> FOR ID ASSIGN ID COMMA CONST COMMA . CONST EXECUTA l_op ENDFOR

    CONST           shift and go to state 223


state 216

    (119) for -> FOR ID ASSIGN ID COMMA CONST EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 224
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 217

    (122) for -> FOR ID ASSIGN CONST COMMA ID COMMA . CONST EXECUTA l_op ENDFOR

    CONST           shift and go to state 225


state 218

    (118) for -> FOR ID ASSIGN CONST COMMA ID EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 226
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 219

    (124) for -> FOR ID ASSIGN CONST COMMA CONST COMMA . CONST EXECUTA l_op ENDFOR

    CONST           shift and go to state 227


state 220

    (120) for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 228
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 221

    (121) for -> FOR ID ASSIGN ID COMMA ID COMMA CONST . EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 229


state 222

    (117) for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 230


state 223

    (123) for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST . EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 231


state 224

    (119) for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 232


state 225

    (122) for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST . EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 233


state 226

    (118) for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 234


state 227

    (124) for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST . EXECUTA l_op ENDFOR

    EXECUTA         shift and go to state 235


state 228

    (120) for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 236


state 229

    (121) for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 237
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 230

    (117) for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .

    ID              reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    READ            reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    IF              reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    $end            reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 117 (for -> FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR .)


state 231

    (123) for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 238
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 232

    (119) for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .

    ID              reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    READ            reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    IF              reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    $end            reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 119 (for -> FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR .)


state 233

    (122) for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 239
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 234

    (118) for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .

    ID              reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    READ            reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    IF              reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    $end            reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 118 (for -> FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR .)


state 235

    (124) for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA . l_op ENDFOR
    (3) l_op -> . op
    (4) l_op -> . op l_op
    (47) op -> . ar_op
    (48) op -> . attr
    (49) op -> . write
    (50) op -> . read
    (51) op -> . func_call
    (52) op -> . repeat
    (53) op -> . ret_op
    (54) op -> . if
    (55) op -> . while
    (56) op -> . for
    (7) ar_op -> . add
    (8) ar_op -> . mul
    (9) ar_op -> . sub
    (10) ar_op -> . div
    (11) ar_op -> . rdiv
    (12) ar_op -> . mod
    (37) attr -> . ID ASSIGN ID
    (38) attr -> . ID ASSIGN CONST
    (39) attr -> . ID ASSIGN ar_op
    (40) attr -> . ID ASSIGN TRUE
    (41) attr -> . ID ASSIGN FALSE
    (42) attr -> . ID ASSIGN func_call
    (127) write -> . PRINT LPAREN l_a_param RPAREN
    (126) read -> . READ LPAREN l_param RPAREN
    (130) func_call -> . ID LPAREN l_a_param RPAREN
    (131) func_call -> . ID LPAREN RPAREN
    (125) repeat -> . REPEAT l_op UNTIL cond_op
    (43) ret_op -> . RETURN ID
    (44) ret_op -> . RETURN CONST
    (45) ret_op -> . RETURN ar_op
    (46) ret_op -> . RETURN func_call
    (114) if -> . IF cond ATUNCI l_op ENDIF
    (115) if -> . IF cond ATUNCI l_op ELSE l_op ENDIF
    (116) while -> . WHILE cond EXECUTA l_op ENDWHILE
    (117) for -> . FOR ID ASSIGN ID COMMA ID EXECUTA l_op ENDFOR
    (118) for -> . FOR ID ASSIGN CONST COMMA ID EXECUTA l_op ENDFOR
    (119) for -> . FOR ID ASSIGN ID COMMA CONST EXECUTA l_op ENDFOR
    (120) for -> . FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR
    (121) for -> . FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (122) for -> . FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR
    (123) for -> . FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (124) for -> . FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR
    (13) add -> . ID PLUS ID
    (14) add -> . CONST PLUS ID
    (15) add -> . ID PLUS CONST
    (16) add -> . CONST PLUS CONST
    (21) mul -> . ID TIMES ID
    (22) mul -> . CONST TIMES ID
    (23) mul -> . ID TIMES CONST
    (24) mul -> . CONST TIMES CONST
    (17) sub -> . ID MINUS ID
    (18) sub -> . CONST MINUS ID
    (19) sub -> . ID MINUS CONST
    (20) sub -> . CONST MINUS CONST
    (25) div -> . ID DIV ID
    (26) div -> . CONST DIV ID
    (27) div -> . ID DIV CONST
    (28) div -> . CONST DIV CONST
    (29) rdiv -> . ID DIVIDE ID
    (30) rdiv -> . CONST DIVIDE ID
    (31) rdiv -> . ID DIVIDE CONST
    (32) rdiv -> . CONST DIVIDE CONST
    (33) mod -> . ID MOD ID
    (34) mod -> . CONST MOD ID
    (35) mod -> . ID MOD CONST
    (36) mod -> . CONST MOD CONST

    ID              shift and go to state 7
    PRINT           shift and go to state 25
    READ            shift and go to state 26
    REPEAT          shift and go to state 27
    RETURN          shift and go to state 28
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    CONST           shift and go to state 24

    l_op                           shift and go to state 240
    op                             shift and go to state 5
    ar_op                          shift and go to state 8
    attr                           shift and go to state 9
    write                          shift and go to state 10
    read                           shift and go to state 11
    func_call                      shift and go to state 12
    repeat                         shift and go to state 13
    ret_op                         shift and go to state 14
    if                             shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    add                            shift and go to state 18
    mul                            shift and go to state 19
    sub                            shift and go to state 20
    div                            shift and go to state 21
    rdiv                           shift and go to state 22
    mod                            shift and go to state 23

state 236

    (120) for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .

    ID              reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    READ            reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    IF              reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    $end            reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 120 (for -> FOR ID ASSIGN CONST COMMA CONST EXECUTA l_op ENDFOR .)


state 237

    (121) for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 241


state 238

    (123) for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 242


state 239

    (122) for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 243


state 240

    (124) for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op . ENDFOR

    ENDFOR          shift and go to state 244


state 241

    (121) for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .

    ID              reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    READ            reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    IF              reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    $end            reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 121 (for -> FOR ID ASSIGN ID COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)


state 242

    (123) for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .

    ID              reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    READ            reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    IF              reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    $end            reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 123 (for -> FOR ID ASSIGN ID COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)


state 243

    (122) for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .

    ID              reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    READ            reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    IF              reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    $end            reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 122 (for -> FOR ID ASSIGN CONST COMMA ID COMMA CONST EXECUTA l_op ENDFOR .)


state 244

    (124) for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .

    ID              reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    PRINT           reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    READ            reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    REPEAT          reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    RETURN          reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    IF              reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    WHILE           reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    FOR             reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    CONST           reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    $end            reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    UNTIL           reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDIF           reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ELSE            reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDWHILE        reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFUNCTION     reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)
    ENDFOR          reduce using rule 124 (for -> FOR ID ASSIGN CONST COMMA CONST COMMA CONST EXECUTA l_op ENDFOR .)

